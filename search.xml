<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>TypeScript</title>
    <url>/2021/01/04/Object/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>class的总结</title>
    <url>/2020/12/28/class/</url>
    <content><![CDATA[<h3 id="js语言中，生成实例对象的传统方法是构造函数"><a href="#js语言中，生成实例对象的传统方法是构造函数" class="headerlink" title="js语言中，生成实例对象的传统方法是构造函数"></a>js语言中，生成实例对象的传统方法是构造函数</h3><pre><code>function Point(x, y) &#123;
  this.x = x;
  this.y = y;
&#125;

Point.prototype.toString = function () &#123;
  return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;;
&#125;;

var p = new Point(1, 2);</code></pre>
<h3 id="ES6-提供了更接近传统语言的写法，引入了-Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。"><a href="#ES6-提供了更接近传统语言的写法，引入了-Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。" class="headerlink" title="ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。"></a>ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。</h3><h3 id="改写-同上"><a href="#改写-同上" class="headerlink" title="改写,同上"></a>改写,同上</h3><pre><code>class Point &#123;
  constructor(x, y) &#123;
    this.x = x;
    this.y = y;
  &#125;

  toString() &#123;
    return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;;
  &#125;
&#125;</code></pre>
<h3 id="class-类有一个constructor方法，这就是构造方法-就算你不调用也会执行-this则代表了实例对象。"><a href="#class-类有一个constructor方法，这就是构造方法-就算你不调用也会执行-this则代表了实例对象。" class="headerlink" title="class 类有一个constructor方法，这就是构造方法,(就算你不调用也会执行) this则代表了实例对象。"></a>class 类有一个constructor方法，这就是构造方法,(就算你不调用也会执行) this则代表了实例对象。</h3><h3 id="定义类方法不需要function关键字-Point也不是对象-各个方法之间也不需要用’-’隔开。"><a href="#定义类方法不需要function关键字-Point也不是对象-各个方法之间也不需要用’-’隔开。" class="headerlink" title="定义类方法不需要function关键字,Point也不是对象,各个方法之间也不需要用’,’隔开。"></a>定义类方法不需要function关键字,Point也不是对象,各个方法之间也不需要用’,’隔开。</h3><pre><code>class Point &#123;
  // ...
&#125;

typeof Point // &quot;function&quot;
Point === Point.prototype.constructor // true</code></pre>
<h3 id="这代表类数据类型是函数，使用时也是对类使用-new-命令-跟构造函数的用法完全一致。"><a href="#这代表类数据类型是函数，使用时也是对类使用-new-命令-跟构造函数的用法完全一致。" class="headerlink" title="这代表类数据类型是函数，使用时也是对类使用 new 命令,跟构造函数的用法完全一致。"></a>这代表类数据类型是函数，使用时也是对类使用 new 命令,跟构造函数的用法完全一致。</h3><pre><code>const b = new Point();
b.toString() //调用</code></pre>
<h3 id="注·类的所有方法都定义在类的prototype属性上面。调用类的方法-其实就是调用原型上的方法"><a href="#注·类的所有方法都定义在类的prototype属性上面。调用类的方法-其实就是调用原型上的方法" class="headerlink" title="注·类的所有方法都定义在类的prototype属性上面。调用类的方法,其实就是调用原型上的方法."></a>注·类的所有方法都定义在类的prototype属性上面。调用类的方法,其实就是调用原型上的方法.</h3><p><font color=blue><strong>类内部定义的所有方法，都是不可枚举的(non-enumerable),这和es5不同</strong></font></p>
<pre><code>**es6**
class Point &#123;
  constructor(x, y) &#123;
    // ...
  &#125;
  toString() &#123;
    // ...
  &#125;
&#125;
Object.keys(Point.prototype)
// []
Object.getOwnPropertyNames(Point.prototype)
// [&quot;constructor&quot;,&quot;toString&quot;]</code></pre>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><pre><code>es5
var Point = function (x, y) &#123;
  // ...
&#125;;
Point.prototype.toString = function () &#123;
  // ...
&#125;;
Object.keys(Point.prototype)
// [&quot;toString&quot;]
Object.getOwnPropertyNames(Point.prototype)
// [&quot;constructor&quot;,&quot;toString&quot;]</code></pre>
<h3 id="类的实例-实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）"><a href="#类的实例-实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）" class="headerlink" title="类的实例(实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）)"></a>类的实例(实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）)</h3><pre><code>//定义类
class Point &#123;

  constructor(x, y) &#123;
    this.x = x;
    this.y = y;
  &#125;

  toString() &#123;
    return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;;
  &#125;

&#125;

var point = new Point(2, 3);

point.toString() // (2, 3)

point.hasOwnProperty(&#39;x&#39;) // true
point.hasOwnProperty(&#39;y&#39;) // true
point.hasOwnProperty(&#39;toString&#39;) // false
point.__proto__.hasOwnProperty(&#39;toString&#39;) // true</code></pre>
<h5 id="x和y都是实例point自身属性，所以hasOwnProperty-方法返回true，而toString-是原型对象的属性上，所以hasOwnProperty-方法返回false"><a href="#x和y都是实例point自身属性，所以hasOwnProperty-方法返回true，而toString-是原型对象的属性上，所以hasOwnProperty-方法返回false" class="headerlink" title="x和y都是实例point自身属性，所以hasOwnProperty()方法返回true，而toString()是原型对象的属性上，所以hasOwnProperty()方法返回false"></a>x和y都是实例point自身属性，所以hasOwnProperty()方法返回true，而toString()是原型对象的属性上，所以hasOwnProperty()方法返回false</h5><h3 id="类的所有实例共享一个原型对象"><a href="#类的所有实例共享一个原型对象" class="headerlink" title="类的所有实例共享一个原型对象"></a>类的所有实例共享一个原型对象</h3><pre><code>var p1 = new Point(2,3);
var p2 = new Point(3,2);

p1.__proto__ === p2.__proto__
//true</code></pre>
<h3 id="因为他们的原型都是Point-prototype，所以为true。"><a href="#因为他们的原型都是Point-prototype，所以为true。" class="headerlink" title="因为他们的原型都是Point.prototype，所以为true。"></a>因为他们的原型都是Point.prototype，所以为true。</h3><h3 id="这也意味着，可以通过实例的-proto-属性为“类”添加方法。我们可以使用-Object-getPrototypeOf-方法来获取实例对象的原型，然后再来为原型添加方法-属性。"><a href="#这也意味着，可以通过实例的-proto-属性为“类”添加方法。我们可以使用-Object-getPrototypeOf-方法来获取实例对象的原型，然后再来为原型添加方法-属性。" class="headerlink" title="这也意味着，可以通过实例的__proto__属性为“类”添加方法。我们可以使用 Object.getPrototypeOf 方法来获取实例对象的原型，然后再来为原型添加方法/属性。"></a>这也意味着，可以通过实例的__proto__属性为“类”添加方法。我们可以使用 Object.getPrototypeOf 方法来获取实例对象的原型，然后再来为原型添加方法/属性。</h3><pre><code>p1.__proto__.printName = function () &#123; return &#39;Oops&#39; &#125;;

p1.printName() // &quot;Oops&quot;
p2.printName() // &quot;Oops&quot;

var p3 = new Point(4,2);
p3.printName() // &quot;Oops&quot;</code></pre>
<p><strong>使用实例的__proto__属性改写原型，必须相当谨慎，不推荐使用，因为这会改变“类”的原始定义，影响到所有实例</strong></p>
<h2 id="取值函数-getter-和存值函数-setter-在类的内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为"><a href="#取值函数-getter-和存值函数-setter-在类的内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为" class="headerlink" title="取值函数(getter)和存值函数(setter) 在类的内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为"></a>取值函数(getter)和存值函数(setter) 在类的内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为</h2><h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><pre><code>class MyClass &#123;
  constructor() &#123;
    // ...
  &#125;
  get prop() &#123;
    return &#39;getter&#39;;
  &#125;
  set prop(value) &#123;
    console.log(&#39;setter: &#39;+value);
  &#125;
&#125;

let inst = new MyClass();

inst.prop = 123;// setter: 123

inst.prop // getter</code></pre>
<h3 id="prop属性有对应的存值函数和取值函数，因此赋值和读取行为都被自定义了。"><a href="#prop属性有对应的存值函数和取值函数，因此赋值和读取行为都被自定义了。" class="headerlink" title="prop属性有对应的存值函数和取值函数，因此赋值和读取行为都被自定义了。"></a>prop属性有对应的存值函数和取值函数，因此赋值和读取行为都被自定义了。</h3><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ol>
<li>严格模式<ul>
<li>类的内部，默认就是严格模式，所以不需要使用use strict指定运行模式</li>
</ul>
</li>
<li>不存在提升<ul>
<li>类不存在变量提升<pre><code>new Foo(); // ReferenceError
class Foo &#123;&#125;</code></pre>
</li>
</ul>
</li>
<li>name 属性<ul>
<li>ES6 的类只是 ES5 的构造函数的一层包装，所以函数的许多特性都被Class继承，包括name属性<pre><code>class Point&#123;&#125;
console.log(Point.name) // &#39;Point&#39;</code></pre>
name属性总是返回紧跟在class关键字后面的类名</li>
</ul>
</li>
<li>Generator 方法<ul>
<li>如果某个方法之前加上星号（*），就表示该方法是一个 Generator 函数。<br>```<br>class Foo {<br>constructor(…args) {<br>this.args = args;<br>}</li>
</ul>
</li>
</ol>
<ul>
<li><a href="">Symbol.iterator</a> {<br>for (let arg of this.args) {<br>  yield arg;<br>}<br>}<br>}</li>
</ul>
<p>for (let x of new Foo(‘hello’, ‘world’)) {<br>  console.log(x);<br>}<br>// hello<br>// world</p>
<pre><code>* Foo类的Symbol.iterator方法前有一个星号，表示该方法是一个 Generator 函数。Symbol.iterator方法返回一个Foo类的默认遍历器，for...of循环会自动调用这个遍历器。
5. this 的指向
   类的方法内部如果含有this，它默认指向类的实例

## 静态方法 
   * 类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。(如果静态方法包含this关键字，这个this指的是类,父类的静态方法，可以被子类继承)
   * 静态方法也是可以从super对象上调用的

## 实例属性新写法

​     实例属性除了定义在constructor()方法里面的this上面也可以定义在类的最顶层。



```javascript
class IncreasingCounter&#123;
  constructor()&#123;
     this._count = 0
  &#125;
  get value()&#123;
      console.log(&#39;Getting the current value!&#39;);
      return this._count;
  &#125;
    increment()&#123;
        this,_count++
    &#125;
&#125;</code></pre>
]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/12/25/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>TypeScript</title>
    <url>/2020/12/30/TypeScript/</url>
    <content><![CDATA[<h3 id="1-基础类型"><a href="#1-基础类型" class="headerlink" title="1.基础类型"></a>1.基础类型</h3><p><strong>为了让程序有价值，我们需要能够处理最简单的数据单元：数字，字符串，结构体，布尔值等。TypeScript支持与javaScript几乎相同的数据类型，此外还提供了实用的的枚举类型方便我们使用。</strong></p>
<h4 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h4>]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>egg和koa面试题总结</title>
    <url>/2021/02/22/vue%E5%92%8Creact%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="1-Node模块机制"><a href="#1-Node模块机制" class="headerlink" title="(1).  Node模块机制"></a>(1).  Node模块机制</h2><h3 id="1-Node中，每个文件模块都是一个对象，它的定义如下"><a href="#1-Node中，每个文件模块都是一个对象，它的定义如下" class="headerlink" title="1.Node中，每个文件模块都是一个对象，它的定义如下"></a>1.Node中，每个文件模块都是一个对象，它的定义如下</h3><pre><code class="js">function Module(id, parent) &#123;
 this.id = id;
 this.exports = &#123;&#125;;
 this.parent = parent;
 this.filename = null;
 this.loaded = false;
 this.children = [];
&#125;
 
module.exports = Module;
 
var module = new Module(filename, parent);</code></pre>
<p>所有的模块都是 Module 的实例。可以看到，当前模块（module.js）也是 Module 的一个实例。</p>
<h3 id="2-请介绍一下require的模块加载机制"><a href="#2-请介绍一下require的模块加载机制" class="headerlink" title="2.请介绍一下require的模块加载机制"></a>2.请介绍一下require的模块加载机制</h3><ul>
<li>1、先计算模块路径</li>
<li>2、如果模块在缓存里面，取出缓存</li>
<li>3、加载模块</li>
<li>4、的输出模块的exports属性即可</li>
</ul>
<pre><code class="js">// require 其实内部调用 Module._load 方法
Module._load = function(request, parent, isMain) &#123;
 // 计算绝对路径
 var filename = Module._resolveFilename(request, parent);

 // 第一步：如果有缓存，取出缓存
 var cachedModule = Module._cache[filename];
 if (cachedModule) &#123;
 return cachedModule.exports;

 // 第二步：是否为内置模块
 if (NativeModule.exists(filename)) &#123;
 return NativeModule.require(filename);
 &#125;

 /********************************这里注意了**************************/
 // 第三步：生成模块实例，存入缓存
 // 这里的Module就是我们上面的1.1定义的Module
 var module = new Module(filename, parent);
 Module._cache[filename] = module;

 /********************************这里注意了**************************/
 // 第四步：加载模块
 // 下面的module.load实际上是Module原型上有一个方法叫Module.prototype.load
 try &#123;
 module.load(filename);
 hadException = false;
 &#125; finally &#123;
 if (hadException) &#123;
  delete Module._cache[filename];
 &#125;
 &#125;

 // 第五步：输出模块的exports属性
 return module.exports;
&#125;;</code></pre>
<h3 id="3-加载模块时，为什么每个模块都有-dirname-filename属性呢，new-Module的时候我们看到第一部分没有这两个属性的，那么这两个属性是从哪里来的"><a href="#3-加载模块时，为什么每个模块都有-dirname-filename属性呢，new-Module的时候我们看到第一部分没有这两个属性的，那么这两个属性是从哪里来的" class="headerlink" title="3. 加载模块时，为什么每个模块都有__dirname,__filename属性呢，new Module的时候我们看到第一部分没有这两个属性的，那么这两个属性是从哪里来的?"></a>3. 加载模块时，为什么每个模块都有__dirname,__filename属性呢，new Module的时候我们看到第一部分没有这两个属性的，那么这两个属性是从哪里来的?</h3><pre><code class="js">// 上面(1.2部分)的第四步module.load(filename)
// 这一步，module模块相当于被包装了，包装形式如下
// 加载js模块，相当于下面的代码（加载node模块和json模块逻辑不一样）
(function (exports, require, module, __filename, __dirname) &#123;
 // 模块源码
 // 假如模块代码如下
 var math = require(&#39;math&#39;);
 exports.area = function(radius)&#123;
  return Math.PI * radius * radius
 &#125;
&#125;);</code></pre>
<p><strong>每个module里面都会传入__filename, __dirname参数，这两个参数并不是module本身就有的，是外界传入的</strong></p>
<h3 id="4-我们知道node导出模块有两种方式，一种是exports-xxx-xxx和Module-exports-有什么区别吗"><a href="#4-我们知道node导出模块有两种方式，一种是exports-xxx-xxx和Module-exports-有什么区别吗" class="headerlink" title="4.我们知道node导出模块有两种方式，一种是exports.xxx=xxx和Module.exports={}有什么区别吗"></a>4.我们知道node导出模块有两种方式，一种是exports.xxx=xxx和Module.exports={}有什么区别吗</h3><ul>
<li>exports其实就是module.exports</li>
<li>其实3问题的代码已经说明问题了，接着我引用廖雪峰大神的讲解，希望能讲的更清楚</li>
</ul>
<pre><code class="js">module.exports vs exports
很多时候，你会看到，在Node环境中，有两种方法可以在一个模块中输出变量：

方法一：对module.exports赋值：

// hello.js

function hello() &#123;
 console.log(&#39;Hello, world!&#39;);
&#125;

function greet(name) &#123;
 console.log(&#39;Hello, &#39; + name + &#39;!&#39;);
&#125;

module.exports = &#123;
 hello: hello,
 greet: greet
&#125;;
方法二：直接使用exports：

// hello.js

function hello() &#123;
 console.log(&#39;Hello, world!&#39;);
&#125;

function greet(name) &#123;
 console.log(&#39;Hello, &#39; + name + &#39;!&#39;);
&#125;

function hello() &#123;
 console.log(&#39;Hello, world!&#39;);
&#125;

exports.hello = hello;
exports.greet = greet;
但是你不可以直接对exports赋值：

// 代码可以执行，但是模块并没有输出任何变量:
exports = &#123;
 hello: hello,
 greet: greet
&#125;;
如果你对上面的写法感到十分困惑，不要着急，我们来分析Node的加载机制：

首先，Node会把整个待加载的hello.js文件放入一个包装函数load中执行。在执行这个load()函数前，Node准备好了module变量：

var module = &#123;
 id: &#39;hello&#39;,
 exports: &#123;&#125;
&#125;;
load()函数最终返回module.exports：

var load = function (exports, module) &#123;
 // hello.js的文件内容
 ...
 // load函数返回:
 return module.exports;
&#125;;

var exported = load(module.exports, module);
也就是说，默认情况下，Node准备的exports变量和module.exports变量实际上是同一个变量，并且初始化为空对象&#123;&#125;，于是，我们可以写：

exports.foo = function () &#123; return &#39;foo&#39;; &#125;;
exports.bar = function () &#123; return &#39;bar&#39;; &#125;;
也可以写：

module.exports.foo = function () &#123; return &#39;foo&#39;; &#125;;
module.exports.bar = function () &#123; return &#39;bar&#39;; &#125;;
换句话说，Node默认给你准备了一个空对象&#123;&#125;，这样你可以直接往里面加东西。

但是，如果我们要输出的是一个函数或数组，那么，只能给module.exports赋值：

module.exports = function () &#123; return &#39;foo&#39;; &#125;;
给exports赋值是无效的，因为赋值后，module.exports仍然是空对象&#123;&#125;。

结论
如果要输出一个键值对象&#123;&#125;，可以利用exports这个已存在的空对象&#123;&#125;，并继续在上面添加新的键值；

如果要输出一个函数或数组，必须直接对module.exports对象赋值。

所以我们可以得出结论：直接对module.exports赋值，可以应对任何情况：

module.exports = &#123;
 foo: function () &#123; return &#39;foo&#39;; &#125;
&#125;;
或者：

module.exports = function () &#123; return &#39;foo&#39;; &#125;;
最终，我们强烈建议使用module.exports = xxx的方式来输出模块变量，这样，你只需要记忆一种方法。</code></pre>
<h2 id="2-node异步"><a href="#2-node异步" class="headerlink" title="(2). node异步"></a>(2). node异步</h2><h3 id="1-请介绍一下Node事件循环的流程"><a href="#1-请介绍一下Node事件循环的流程" class="headerlink" title="1 请介绍一下Node事件循环的流程"></a>1 请介绍一下Node事件循环的流程</h3><ul>
<li>在进程启动时，Node便会创建一个类似于while(true)的循环，每执行一次循环体的过程我们成为Tick。</li>
<li>每个Tick的过程就是查看是否有事件待处理。如果有就取出事件及其相关的回调函数。然后进入下一个循环，如果不再有事件处理，就退出进程。</li>
</ul>
<h3 id="2-在每个tick的过程中，如何判断是否有事件需要处理呢？"><a href="#2-在每个tick的过程中，如何判断是否有事件需要处理呢？" class="headerlink" title="2.在每个tick的过程中，如何判断是否有事件需要处理呢？"></a>2.在每个tick的过程中，如何判断是否有事件需要处理呢？</h3><ol>
<li>每个事件循环中有一个或者多个观察者，而判断是否有事件需要处理的过程就是向这些观察者询问是否有要处理的事件。</li>
<li>在Node中，事件主要来源于网络请求、文件的I/O等，这些事件对应的观察者有文件I/O观察者，网络I/O的观察者。</li>
<li>事件循环是一个典型的生产者/消费者模型。异步I/O，网络请求等则是事件的生产者，源源不断为Node提供不同类型的事件，这些事件被传递到对应的观察者那里，事件循环则从观察者那里取出事件并处理。</li>
<li>在windows下，这个循环基于IOCP创建，在*nix下则基于多线程创建</li>
</ol>
<h3 id="3-请谈一下内存泄漏是什么，以及常见内存泄漏的原因，和排查的方法？"><a href="#3-请谈一下内存泄漏是什么，以及常见内存泄漏的原因，和排查的方法？" class="headerlink" title="3.请谈一下内存泄漏是什么，以及常见内存泄漏的原因，和排查的方法？"></a>3.请谈一下内存泄漏是什么，以及常见内存泄漏的原因，和排查的方法？</h3><h4 id="什么是内存泄漏"><a href="#什么是内存泄漏" class="headerlink" title="什么是内存泄漏"></a>什么是内存泄漏</h4><ul>
<li>内存泄漏(Memory Leak)指由于疏忽或错误造成程序未能释放已经不再使用的内存的情况。</li>
<li>如果内存泄漏的位置比较关键，那么随着处理的进行可能持有越来越多的无用内存，这些无用的内存变多会引起服务器响应速度变慢。</li>
<li>严重的情况下导致内存达到某个极限(可能是进程的上限，如 v8 的上限;也可能是系统可提供的内存上限)会使得应用程序崩溃。</li>
</ul>
<p>常见内存泄漏</p>
<p>一、全局变量</p>
<pre><code class="js">a = 10; //未声明对象。 
global.b = 11; //全局变量引用 这种比较简单的原因，全局变量直接挂在 root 对象上，不会被清除掉。</code></pre>
<p>二、闭包</p>
<pre><code class="js">function out() &#123;
    const bigData = new Buffer(100);  
    inner = function () &#123;

    &#125; 
&#125;</code></pre>
<p>闭包会引用到父级函数中的变量，如果闭包未释放，就会导致内存泄漏。上面例子是 inner 直接挂在了 root 上，那么每次执行 out 函数所产生的 bigData 都不会释放，从而导致内存泄漏。</p>
<p>需要注意的是，这里举得例子只是简单的将引用挂在全局对象上，实际的业务情况可能是挂在某个可以从 root 追溯到的对象上导致的。</p>
<p>三、Node.js 的事件监听也可能出现的内存泄漏。例如对同一个事件重复监听，忘记移除(removeListener)，将造成内存泄漏。这种情况很容易在复用对象上添加事件时出现，所以事件重复监听可能收到如下警告：</p>
<pre><code>emitter.setMaxListeners() to increase limit</code></pre>
<p>例如，Node.js 中 Agent 的 keepAlive 为 true 时，可能造成的内存泄漏。当 Agent keepAlive 为 true 的时候，将会复用之前使用过的 socket，如果在 socket 上添加事件监听，忘记清除的话，因为 socket 的复用，将导致事件重复监听从而产生内存泄漏。</p>
<p>原理上与前一个添加事件监听的时候忘了清除是一样的。在使用 Node.js 的 http 模块时，不通过 keepAlive 复用是没有问题的，复用了以后就会可能产生内存泄漏。所以，你需要了解添加事件监听的对象的生命周期，并注意自行移除。</p>
<p><strong>排查方法</strong></p>
<ul>
<li>想要定位内存泄漏，通常会有两种情况：</li>
<li>对于只要正常使用就可以重现的内存泄漏，这是很简单的情况只要在测试环境模拟就可以排查了。</li>
<li>对于偶然的内存泄漏，一般会与特殊的输入有关系。想稳定重现这种输入是很耗时的过程。如果不能通过代码的日志定位到这个特殊的输入，那么推荐去生产环境打印内存快照了。</li>
<li>需要注意的是，打印内存快照是很耗 CPU 的操作，可能会对线上业务造成影响。快照工具推荐使用 heapdump 用来保存内存快照，使用 devtool 来查看内存快照。</li>
<li>使用 heapdump 保存内存快照时，只会有 Node.js 环境中的对象，不会受到干扰(如果使用 node-inspector 的话，快照中会有前端的变量干扰)。</li>
<li>PS：安装 heapdump 在某些 Node.js 版本上可能出错，建议使用 npm install heapdump -target=Node.js 版本来安装。</li>
</ul>
<h2 id="3-Buffer模块"><a href="#3-Buffer模块" class="headerlink" title="3.Buffer模块"></a>3.Buffer模块</h2><h3 id="1-新建Buffer会占用V8分配的内存吗"><a href="#1-新建Buffer会占用V8分配的内存吗" class="headerlink" title="1 新建Buffer会占用V8分配的内存吗"></a>1 新建Buffer会占用V8分配的内存吗</h3><p>  不会，Buffer属于堆外内存，不是V8分配的。</p>
<h3 id="2-Buffer-alloc和Buffer-allocUnsafe的区别"><a href="#2-Buffer-alloc和Buffer-allocUnsafe的区别" class="headerlink" title="2.Buffer.alloc和Buffer.allocUnsafe的区别"></a>2.<strong>Buffer.alloc和Buffer.allocUnsafe的区别</strong></h3><p>Buffer.allocUnsafe创建的 Buffer 实例的底层内存是未初始化的。 新创建的 Buffer 的内容是未知的，可能包含敏感数据。 使用 Buffer.alloc() 可以创建以零初始化的 Buffer 实例。</p>
<h3 id="3-Buffer的内存分配机制"><a href="#3-Buffer的内存分配机制" class="headerlink" title="3. Buffer的内存分配机制**"></a>3. Buffer的内存分配机制**</h3><p>为了高效的使用申请来的内存，Node采用了slab分配机制。slab是一种动态的内存管理机制。Node以8kb为界限来来区分Buffer为大对象还是小对象，如果是小于8kb就是小Buffer，大于8kb就是大Buffer。</p>
<p>例如第一次分配一个1024字节的Buffer，Buffer.alloc(1024),那么这次分配就会用到一个slab，接着如果继续Buffer.alloc(1024),那么上一次用的slab的空间还没有用完，因为总共是8kb，1024+1024 = 2048个字节，没有8kb，所以就继续用这个slab给Buffer分配空间</p>
<h3 id="4-Buffer乱码问题"><a href="#4-Buffer乱码问题" class="headerlink" title="4.Buffer乱码问题"></a>4.Buffer乱码问题</h3><p>设置rs.setEncoding(‘utf8’)可以解决乱码问题</p>
<h3 id="5-请问创建子进程的方法有哪些，简单说一下它们的区别"><a href="#5-请问创建子进程的方法有哪些，简单说一下它们的区别" class="headerlink" title="5 请问创建子进程的方法有哪些，简单说一下它们的区别"></a>5 请问创建子进程的方法有哪些，简单说一下它们的区别</h3><p>创建子进程的方法大致有：</p>
<ul>
<li>spawn()： 启动一个子进程来执行命令</li>
<li>exec(): 启动一个子进程来执行命令，与spawn()不同的是其接口不同，它有一个回调函数获知子进程的状况</li>
<li>execFlie(): 启动一个子进程来执行可执行文件</li>
<li>fork(): 与spawn()类似，不同电在于它创建Node子进程需要执行js文件</li>
<li>spawn()与exec()、execFile()不同的是，后两者创建时可以指定timeout属性设置超时时间，一旦创建的进程超过设定的时间就会被杀死</li>
<li>exec()与execFile()不同的是，exec()适合执行已有命令，execFile()适合执行文件</li>
</ul>
<h3 id="6-请问你知道spawn在创建子进程的时候，第三个参数有一个stdio选项吗，这个选项的作用是什么，默认的值是什么。"><a href="#6-请问你知道spawn在创建子进程的时候，第三个参数有一个stdio选项吗，这个选项的作用是什么，默认的值是什么。" class="headerlink" title="6. 请问你知道spawn在创建子进程的时候，第三个参数有一个stdio选项吗，这个选项的作用是什么，默认的值是什么。"></a>6. <strong>请问你知道spawn在创建子进程的时候，第三个参数有一个stdio选项吗，这个选项的作用是什么，默认的值是什么。</strong></h3><ul>
<li>选项用于配置在父进程和子进程之间建立的管道。</li>
<li>默认情况下，子进程的 stdin、 stdout 和 stderr 会被重定向到 ChildProcess 对象上相应的 subprocess.stdin、subprocess.stdout 和 subprocess.stderr 流。</li>
<li>这相当于将 options.stdio 设置为 [‘pipe’, ‘pipe’, ‘pipe’]。</li>
</ul>
<h3 id="7-请问实现一个node子进程被杀死，然后自动重启代码的思路"><a href="#7-请问实现一个node子进程被杀死，然后自动重启代码的思路" class="headerlink" title="7.请问实现一个node子进程被杀死，然后自动重启代码的思路"></a>7.<strong>请问实现一个node子进程被杀死，然后自动重启代码的思路</strong></h3><p>在创建子进程的时候就让子进程监听exit事件，如果被杀死就重新fork一下</p>
<pre><code class="js">var createWorker = function()&#123;
 var worker = fork(__dirname + &#39;worker.js&#39;)
 worker.on(&#39;exit&#39;, function()&#123;
  console.log(&#39;Worker&#39; + worker.pid + &#39;exited&#39;);
  // 如果退出就创建新的worker
  createWorker()
 &#125;)
&#125;</code></pre>
<h3 id="8-实现限量重启，比如我最多让其在1分钟内重启5次，超过了就报警给运维"><a href="#8-实现限量重启，比如我最多让其在1分钟内重启5次，超过了就报警给运维" class="headerlink" title="8.实现限量重启，比如我最多让其在1分钟内重启5次，超过了就报警给运维"></a>8.<strong>实现限量重启，比如我最多让其在1分钟内重启5次，超过了就报警给运维</strong></h3><ul>
<li>思路大概是在创建worker的时候，就判断创建的这个worker是否在1分钟内重启次数超过5次</li>
<li>所以每一次创建worker的时候都要记录这个worker 创建时间，放入一个数组队列里面，每次创建worker都去取队列里前5条记录</li>
<li>如果这5条记录的时间间隔小于1分钟，就说明到了报警的时候了</li>
</ul>
<h2 id="4-中间件"><a href="#4-中间件" class="headerlink" title="4.中间件"></a>4.中间件</h2><h3 id="1-如果使用过koa、egg这两个Node框架，请简述其中的中间件原理，最好用代码表示一下"><a href="#1-如果使用过koa、egg这两个Node框架，请简述其中的中间件原理，最好用代码表示一下" class="headerlink" title="1.如果使用过koa、egg这两个Node框架，请简述其中的中间件原理，最好用代码表示一下"></a>1.如果使用过koa、egg这两个Node框架，请简述其中的中间件原理，最好用代码表示一下</h3><p><img src="https://img.jbzj.com/file_images/article/201910/2019100915292845.png" alt="img"></p>
<p>中间件执行就像洋葱一样，最早use的中间件，就放在最外层。处理顺序从左到右，左边接收一个request，右边输出返回response</p>
<p>一般的中间件都会执行两次，调用next之前为第一次，调用next时把控制传递给下游的下一个中间件。当下游不再有中间件或者没有执行next函数时，就将依次恢复上游中间件的行为，让上游中间件执行next之后的代码</p>
<p>例如</p>
<pre><code class="js">const Koa = require(&#39;koa&#39;)
const app = new Koa()
app.use((ctx, next) =&gt; &#123;
 console.log(1)
 next()
 console.log(3)
&#125;)
app.use((ctx) =&gt; &#123;
 console.log(2)
&#125;)
app.listen(3001)
执行结果是1=&gt;2=&gt;3</code></pre>
<p>koa中间件实现源码大致思路如下：</p>
<pre><code class="js">// 注意其中的compose函数，这个函数是实现中间件洋葱模型的关键
// 场景模拟
// 异步 promise 模拟
const delay = async () =&gt; &#123;
 return new Promise((resolve, reject) =&gt; &#123;
 setTimeout(() =&gt; &#123;
  resolve();
 &#125;, 2000);
 &#125;);
&#125;
// 中间间模拟
const fn1 = async (ctx, next) =&gt; &#123;
 console.log(1);
 await next();
 console.log(2);
&#125;
const fn2 = async (ctx, next) =&gt; &#123;
 console.log(3);
 await delay();
 await next();
 console.log(4);
&#125;
const fn3 = async (ctx, next) =&gt; &#123;
 console.log(5);
&#125;

const middlewares = [fn1, fn2, fn3];

// compose 实现洋葱模型
const compose = (middlewares, ctx) =&gt; &#123;
 const dispatch = (i) =&gt; &#123;
 let fn = middlewares[i];
 if(!fn)&#123; return Promise.resolve() &#125;
 return Promise.resolve(fn(ctx, () =&gt; &#123;
  return dispatch(i+1);
 &#125;));
 &#125;
 return dispatch(0);
&#125;

compose(middlewares, 1);</code></pre>
]]></content>
  </entry>
  <entry>
    <title>hook的整理使用</title>
    <url>/2020/12/27/hook/</url>
    <content><![CDATA[<h3 id="hook简介"><a href="#hook简介" class="headerlink" title="hook简介"></a>hook简介</h3><font color=#FF0000 >
     Hook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。
</font>

<h5 id="useState使用"><a href="#useState使用" class="headerlink" title="useState使用"></a>useState使用</h5><pre><code>import React, &#123; useState &#125; from &#39;react&#39;;
function Example() &#123;
  // 声明一个新的叫做 “count” 的 state 变量
  const [count, setCount] = useState(0);
  return (
    &lt;div&gt;
      &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;
      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;
        Click me
      &lt;/button&gt;
    &lt;/div&gt;
  );
&#125;</code></pre>
<h2 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h2><font color=#ff0000>
可以实现在函数组件中使用 state count是值,setCount是修改的方法
</font>

<h2 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h2><pre><code>import React, &#123; useState, useEffect &#125; from &#39;react&#39;;

function Example() &#123;
  const [count, setCount] = useState(0);

  // Similar to componentDidMount and componentDidUpdate:
  useEffect(() =&gt; &#123;
    // Update the document title using the browser API
    document.title = `You clicked $&#123;count&#125; times`;
  &#125;);

  return (
    &lt;div&gt;
      &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;
      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;
        Click me
      &lt;/button&gt;
    &lt;/div&gt;
  );
&#125;</code></pre>
<p><strong>&lt;font color==#00000 &gt;很多情况下，我们希望在组件加载和更新时执行同样的操作。从概念上说，我们希望它在每次渲染之后执行 —— 但 React 的 class 组件没有提供这样的方法。即使我们提取出一个方法，我们还是要在两个地方调用它。</font></strong></p>
<h2 id="useEffect是在加载前或更新时都会使用-替代了componentDidMount-和componentDidUpdate-集合起来"><a href="#useEffect是在加载前或更新时都会使用-替代了componentDidMount-和componentDidUpdate-集合起来" class="headerlink" title="useEffect是在加载前或更新时都会使用 替代了componentDidMount()和componentDidUpdate() 集合起来"></a>useEffect是在加载前或更新时都会使用 替代了componentDidMount()和componentDidUpdate() 集合起来</h2><p><font color=red>不要在循环，条件或嵌套函数中调用 Hook， 确保总是在你的 React 函数的最顶层调用他们。遵守这条规则，你就能确保 Hook 在每一次渲染中都按照同样的顺序被调用。这让 React 能够在多次的 useState 和 useEffect 调用之间保持 hook 状态的正确。<br><font/></p>
<h4 id="useContext-接收一个context对象并返回当前的值"><a href="#useContext-接收一个context对象并返回当前的值" class="headerlink" title="useContext 接收一个context对象并返回当前的值"></a>useContext 接收一个context对象并返回当前的值</h4><pre><code> const value = useContext(MyContext);</code></pre>
<h3 id="注意-他传入的值不是Consumer-消费者-也不是Provider生产者而是context对象本身"><a href="#注意-他传入的值不是Consumer-消费者-也不是Provider生产者而是context对象本身" class="headerlink" title="注意 : 他传入的值不是Consumer(消费者)也不是Provider生产者而是context对象本身"></a>注意 : <font color=blue>他传入的值不是Consumer(消费者)也不是Provider生产者而是context对象本身</font></h3><blockquote>
<p>useContext(MyContext) 只是让你能够读取 context 的值以及订阅 context 的变化。你仍然需要在上层组件树中使用 &lt;MyContext.Provider&gt; 来为下层组件提供 context</p>
</blockquote>
<h2 id="额外的Hook"><a href="#额外的Hook" class="headerlink" title="额外的Hook"></a>额外的Hook</h2><ol>
<li>useReducer<pre><code>const [state, dispatch] = useReducer(reducer, initialArg, init);</code></pre>
<h3 id="它拥有三个值，第一个值是reducer函数-他会返回新的值来覆盖原来的值-第二个值是初始化的参数，第三个值是惰性初始化-需要将-init-函数作为-useReducer-的第三个参数传入，这样初始-state-将被设置为-init-initialArg"><a href="#它拥有三个值，第一个值是reducer函数-他会返回新的值来覆盖原来的值-第二个值是初始化的参数，第三个值是惰性初始化-需要将-init-函数作为-useReducer-的第三个参数传入，这样初始-state-将被设置为-init-initialArg" class="headerlink" title="它拥有三个值，第一个值是reducer函数,他会返回新的值来覆盖原来的值,第二个值是初始化的参数，第三个值是惰性初始化,需要将 init 函数作为 useReducer 的第三个参数传入，这样初始 state 将被设置为 init(initialArg)"></a>它拥有三个值，第一个值是reducer函数,他会返回新的值来覆盖原来的值,第二个值是初始化的参数，第三个值是惰性初始化,需要将 init 函数作为 useReducer 的第三个参数传入，这样初始 state 将被设置为 init(initialArg)</h3></li>
</ol>
<h2 id="注意-传入函数不要在生成dom的函数中-否则首次调用会执行两回"><a href="#注意-传入函数不要在生成dom的函数中-否则首次调用会执行两回" class="headerlink" title="注意 传入函数不要在生成dom的函数中,否则首次调用会执行两回"></a>注意 传入函数不要在生成dom的函数中,否则首次调用会执行两回</h2><pre><code>function init(initialCount) &#123;
    return &#123; count: initialCount &#125;;
&#125;
function reducer(state, action) &#123;
    switch (action.type) &#123;
        case &#39;increment&#39;:
          return &#123; count: state.count + 1 &#125;;
        case &#39;decrement&#39;:
          return &#123; count: state.count - 1 &#125;;
        case &#39;reset&#39;:
          return init(action.payload);
        default:
          throw new Error();
    &#125;
&#125;
function Counter(&#123; initialCount &#125;) &#123;
    const [state, dispatch] = useReducer(reducer, initialCount, init);
    return (
        &lt;div&gt;
          Count: &#123;state.count&#125;
          &lt;button
            onClick=&#123;() =&gt; dispatch(&#123; type: &#39;reset&#39;, payload: initialCount &#125;)&#125;&gt;
            Reset
          &lt;/button&gt;
          &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: &#39;decrement&#39; &#125;)&#125;&gt;-&lt;/button&gt;
          &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: &#39;increment&#39; &#125;)&#125;&gt;+&lt;/button&gt;
        &lt;div /&gt;
    );
&#125;</code></pre>
<h3 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h3><pre><code>const [count, setCount] = useState(1);
    const [val, setVal] = useState(&#39;&#39;);
    const [count, setCount] = useState(1);
    const callback = useCallback(() =&gt; &#123;
        console.log(count);
    &#125;, [count]);
    return &lt;div&gt;
        &lt;h4&gt;&#123;count&#125;&lt;/h4&gt;
        &lt;h4&gt;&#123;set.size&#125;&lt;/h4&gt;
        &lt;div&gt;
            &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;+&lt;/button&gt;
            &lt;input value=&#123;val&#125; onChange=&#123;event =&gt; setVal(event.target.value)&#125;/&gt;
        &lt;/div&gt;
    &lt;/div&gt;;
</code></pre>
<ul>
<li>在所依赖的count变化时会返回新的函数,count没有变化时不变<h4 id="会在组件第一次渲染的时候执行，之后会在其依赖的变量发生改变时再次执行，并且返回缓存的函数"><a href="#会在组件第一次渲染的时候执行，之后会在其依赖的变量发生改变时再次执行，并且返回缓存的函数" class="headerlink" title="会在组件第一次渲染的时候执行，之后会在其依赖的变量发生改变时再次执行，并且返回缓存的函数"></a>会在组件第一次渲染的时候执行，之后会在其依赖的变量发生改变时再次执行，并且返回缓存的函数</h4><h3 id="其可以应用在父组件向子组件传参-当父组件里面的值变化时，使子组件避免不必要的更新"><a href="#其可以应用在父组件向子组件传参-当父组件里面的值变化时，使子组件避免不必要的更新" class="headerlink" title="其可以应用在父组件向子组件传参,当父组件里面的值变化时，使子组件避免不必要的更新"></a>其可以应用在父组件向子组件传参,当父组件里面的值变化时，使子组件避免不必要的更新</h3></li>
</ul>
<h2 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h2><pre><code>export default function WithMemo() &#123;
    const [count, setCount] = useState(1);
    const [val, setValue] = useState(&#39;&#39;);
    const expensive = useMemo(() =&gt; &#123;
        console.log(&#39;compute&#39;);
        let sum = 0;
        for (let i = 0; i &lt; count * 100; i++) &#123;
            sum += i;
        &#125;
        return sum;
    &#125;, [count]);

    return &lt;div&gt;
        &lt;h4&gt;&#123;count&#125;-&#123;expensive&#125;&lt;/h4&gt;
        &#123;val&#125;
        &lt;div&gt;
            &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;+c1&lt;/button&gt;
            &lt;input value=&#123;val&#125; onChange=&#123;event =&gt; setValue(event.target.value)&#125;/&gt;
        &lt;/div&gt;
    &lt;/div&gt;;</code></pre>
<ul>
<li> 同上,会在组件第一次渲染的时候执行，之后会在其依赖的变量发生改变时再次执行，并且返回缓存的变量<h3 id="使用useMemo来执行昂贵的计算，然后将计算值返回，并且将count作为依赖值传递进去。这样，就只会在count改变的时候触发expensive执行，在修改val的时候，返回上一次缓存的值。"><a href="#使用useMemo来执行昂贵的计算，然后将计算值返回，并且将count作为依赖值传递进去。这样，就只会在count改变的时候触发expensive执行，在修改val的时候，返回上一次缓存的值。" class="headerlink" title="使用useMemo来执行昂贵的计算，然后将计算值返回，并且将count作为依赖值传递进去。这样，就只会在count改变的时候触发expensive执行，在修改val的时候，返回上一次缓存的值。"></a>使用useMemo来执行昂贵的计算，然后将计算值返回，并且将count作为依赖值传递进去。这样，就只会在count改变的时候触发expensive执行，在修改val的时候，返回上一次缓存的值。</h3></li>
</ul>
<h3 id="useRef-返回一个可变的-ref-对象，其-current-属性被初始化为传入的参数。返回的-ref-对象在组件的整个生命周期内保持不变。"><a href="#useRef-返回一个可变的-ref-对象，其-current-属性被初始化为传入的参数。返回的-ref-对象在组件的整个生命周期内保持不变。" class="headerlink" title="useRef  返回一个可变的 ref 对象，其 .current 属性被初始化为传入的参数。返回的 ref 对象在组件的整个生命周期内保持不变。"></a>useRef  返回一个可变的 ref 对象，其 .current 属性被初始化为传入的参数。返回的 ref 对象在组件的整个生命周期内保持不变。</h3><pre><code>const refContainer = useRef(null);</code></pre>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><pre><code>function TextInputWithFocusButton() &#123;
  const inputEl = useRef(null);
  const onButtonClick = () =&gt; &#123;
    // `current` 指向已挂载到 DOM 上的文本输入元素
    inputEl.current.focus();
  &#125;;
  return (
    &lt;div&gt;
      &lt;input ref=&#123;inputEl&#125; type=&quot;text&quot;/&gt;
      &lt;button onClick=&#123;onButtonClick&#125;&gt;Focus the input&lt;/button&gt;
    &lt;/div&gt;
  );
&#125;</code></pre>
<h3 id="还有很多hook方法-例如"><a href="#还有很多hook方法-例如" class="headerlink" title="还有很多hook方法 例如"></a>还有很多hook方法 例如</h3><ol>
<li>useImperativeHandle</li>
<li>useLayoutEffect</li>
<li>useDebugValue</li>
</ol>
<p>下次再见</p>
]]></content>
  </entry>
  <entry>
    <title>vue面试题整理</title>
    <url>/2021/01/28/vue%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h4 id="1-history模式，页面返回404，如何解决"><a href="#1-history模式，页面返回404，如何解决" class="headerlink" title="1. history模式，页面返回404，如何解决?"></a>1. history模式，页面返回404，如何解决?</h4><p>history是html5新增的api，他的功能是修改地址栏但是不像服务器端发送真是请求，如果页面返回404，说明发送了请求到服务器端,并且服务器端对该请求没有做处理，那么解决404的方案就是服务器端对于这类请求重定向到某个页面即可</p>
<h4 id="2-聊一聊commonjs规范"><a href="#2-聊一聊commonjs规范" class="headerlink" title="2.聊一聊commonjs规范"></a>2.聊一聊commonjs规范</h4><h5 id="概述-：-node应用由模块组成，采用的commonjs模块规范。每一个文件就是一个模块，拥有自己独立的作用域，变量，以及方法等，对其他的模块都不可见。CommonJS规范规定，每个模块内部，module变量代表当前模块。这个变量是一个对象，它的exports属性（即module-exports）是对外的接口。加载某个模块，其实是加载该模块的module-exports属性。require方法用于加载模块。"><a href="#概述-：-node应用由模块组成，采用的commonjs模块规范。每一个文件就是一个模块，拥有自己独立的作用域，变量，以及方法等，对其他的模块都不可见。CommonJS规范规定，每个模块内部，module变量代表当前模块。这个变量是一个对象，它的exports属性（即module-exports）是对外的接口。加载某个模块，其实是加载该模块的module-exports属性。require方法用于加载模块。" class="headerlink" title="概述 ： node应用由模块组成，采用的commonjs模块规范。每一个文件就是一个模块，拥有自己独立的作用域，变量，以及方法等，对其他的模块都不可见。CommonJS规范规定，每个模块内部，module变量代表当前模块。这个变量是一个对象，它的exports属性（即module.exports）是对外的接口。加载某个模块，其实是加载该模块的module.exports属性。require方法用于加载模块。"></a>概述 ： node应用由模块组成，采用的commonjs模块规范。每一个文件就是一个模块，拥有自己独立的作用域，变量，以及方法等，对其他的模块都不可见。CommonJS规范规定，每个模块内部，module变量代表当前模块。这个变量是一个对象，它的exports属性（即module.exports）是对外的接口。加载某个模块，其实是加载该模块的module.exports属性。require方法用于加载模块。</h5><h5 id="CommonJS模块的特点如下"><a href="#CommonJS模块的特点如下" class="headerlink" title="CommonJS模块的特点如下 :"></a>CommonJS模块的特点如下 :</h5><h5 id="1-所有代码都运行在模块作用域，不会污染全局作用域。"><a href="#1-所有代码都运行在模块作用域，不会污染全局作用域。" class="headerlink" title="(1)  所有代码都运行在模块作用域，不会污染全局作用域。"></a>(1)  所有代码都运行在模块作用域，不会污染全局作用域。</h5><h5 id="2-模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。"><a href="#2-模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。" class="headerlink" title="(2) 模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。"></a>(2) 模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。</h5><h5 id="3-模块加载的顺序，按照其在代码中出现的顺序。"><a href="#3-模块加载的顺序，按照其在代码中出现的顺序。" class="headerlink" title="(3) 模块加载的顺序，按照其在代码中出现的顺序。"></a>(3) 模块加载的顺序，按照其在代码中出现的顺序。</h5><h5 id="模块加载机制-："><a href="#模块加载机制-：" class="headerlink" title="模块加载机制 ："></a>模块加载机制 ：</h5><h5 id="commonsJS的加载机制，输入的是被输出值的拷贝。也就是说，一旦输出一个值，模块内部的变化就影响不到这个值了。"><a href="#commonsJS的加载机制，输入的是被输出值的拷贝。也就是说，一旦输出一个值，模块内部的变化就影响不到这个值了。" class="headerlink" title="commonsJS的加载机制，输入的是被输出值的拷贝。也就是说，一旦输出一个值，模块内部的变化就影响不到这个值了。"></a>commonsJS的加载机制，输入的是被输出值的拷贝。也就是说，一旦输出一个值，模块内部的变化就影响不到这个值了。</h5><h5 id="require命令-："><a href="#require命令-：" class="headerlink" title="require命令 ："></a>require命令 ：</h5><h5 id="1-require命令用于加载模块文件，相当于读入并执行一个js文件，然后返回该模块的exports对象，没有发现指定模块，则就会报错"><a href="#1-require命令用于加载模块文件，相当于读入并执行一个js文件，然后返回该模块的exports对象，没有发现指定模块，则就会报错" class="headerlink" title="(1) require命令用于加载模块文件，相当于读入并执行一个js文件，然后返回该模块的exports对象，没有发现指定模块，则就会报错"></a>(1) require命令用于加载模块文件，相当于读入并执行一个js文件，然后返回该模块的exports对象，没有发现指定模块，则就会报错</h5><h5 id="2-加载规则"><a href="#2-加载规则" class="headerlink" title="(2) 加载规则 :"></a>(2) 加载规则 :</h5><p>​     a:如果参数字符串以“/”开头，则表示加载的是一个位于绝对路径的模块文件。比如，require(‘/home/marco/foo.js’)将加载/home/marco/foo.js。</p>
<p>​     b.如果参数字符串以“./”开头，则表示加载的是一个位于相对路径（跟当前执行脚本的位置相比）的模块文件。比如，require(‘./circle’)将加载当前脚本同一目录的circle.js。</p>
<p>​     c.如果参数字符串不以“./“或”/“开头，则表示加载的是一个默认提供的核心模块（位于Node的系统安装目录中），或者一个位于各级node_modules目录的已安装模块（全局安装或局部安装）。</p>
<h5 id="模块的缓存：第一次加载该模块，node会缓存该模块。再次加载，直接从缓存中取出该模块的module-exports属性。缓存保存在require-cache中，可操作该属性进行删除。"><a href="#模块的缓存：第一次加载该模块，node会缓存该模块。再次加载，直接从缓存中取出该模块的module-exports属性。缓存保存在require-cache中，可操作该属性进行删除。" class="headerlink" title="模块的缓存：第一次加载该模块，node会缓存该模块。再次加载，直接从缓存中取出该模块的module.exports属性。缓存保存在require.cache中，可操作该属性进行删除。"></a>模块的缓存：第一次加载该模块，node会缓存该模块。再次加载，直接从缓存中取出该模块的module.exports属性。缓存保存在require.cache中，可操作该属性进行删除。</h5><h4 id="3-vue的指令有哪些？作用是什么？"><a href="#3-vue的指令有哪些？作用是什么？" class="headerlink" title="3.vue的指令有哪些？作用是什么？"></a>3.vue的指令有哪些？作用是什么？</h4><pre><code>&#123;&#123;&#125;&#125; : 插值

v-if,v-else-if,v-else : 条件成立渲染

v-show : 根据条件动态切换display的值

v-bind : 动态绑定属性值

v-on : 监听属性

v-modul ：在表单控件或组件上进行双向绑定

v-html : 插入字符串并解析html

v-text：同&#123;&#123;&#125;&#125;  插到标签上</code></pre>
<h4 id="4-eventBus是什么？"><a href="#4-eventBus是什么？" class="headerlink" title="4.eventBus是什么？"></a>4.eventBus是什么？</h4><p>​       是vue跨组件传参的方法，首先在根组件中输入 Vue.prototype.$bus=new Vue()  然后 在要传参的组件中通过this.$bus.$emit传递自定义事件和参数 然后在接收参数的组件中通过this.$bus.$on接收自定义事件名和参数</p>
<h4 id="5-vue-router的原理（history、hash）"><a href="#5-vue-router的原理（history、hash）" class="headerlink" title="5.vue-router的原理（history、hash）"></a>5.vue-router的原理（history、hash）</h4><p>特点是更新视图但不重新请求页面，是前端路由原理的核心之一，目前在浏览器环境中这一功能的实现主要有2种方式,Hash模式和History模式</p>
<p>（1）利用URL中的hash(“#”);</p>
<p>（2）利用History,在HTML5中新增的方法;</p>
<p>1、Hash模式：<br>   hash（#）是URL 的锚点，代表的是网页中的一个位置，单单改变#后的部分，浏览器只会滚动到相应位置，不会重新加载网页，也就是说 #是用来指导浏览器动作的，对服务器端完全无用，HTTP请求中也不会不包括#；同时每一次改变#后的部分，都会在浏览器的访问历史中增加一个记录，使用”后退”按钮，就可以回到上一个位置；</p>
<p>2、History模式： </p>
<p>  HTML5 History API提供了一种功能，能让开发人员在不刷新整个页面的情况下修改站点的URL，就是利用 history.pushState API 来完成 URL 跳转而无须重新加载页面；</p>
<p>通常情况下，我们会选择使用History模式，原因就是Hash模式下URL带着‘#’会显得不美观；</p>
]]></content>
  </entry>
  <entry>
    <title>JavaScript的严格模式</title>
    <url>/2020/12/30/%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h4 id="声明严格模式"><a href="#声明严格模式" class="headerlink" title="声明严格模式"></a>声明严格模式</h4><p>通过在脚本或函数的头部添加use strict,表达式来声明。</p>
<pre><code class="js">&#39;use strict&#39;
x = 3.14;   // 报错(x 未定义)</code></pre>
<p>注:在函数内部声明的变量是局部作用域(只在函数内使用严格模式)</p>
<pre><code class="js">function myFunction()&#123;
    &#39;use strict&#39;
    y = 3.15 //报错(未定义)
&#125;</code></pre>
<h4 id="严格模式限制"><a href="#严格模式限制" class="headerlink" title="严格模式限制"></a>严格模式限制</h4><h5 id="1-不允许使用未声明的变量："><a href="#1-不允许使用未声明的变量：" class="headerlink" title="1.不允许使用未声明的变量："></a>1.不允许使用未声明的变量：</h5><pre><code class="js">&#39;use strict&#39;;
x = 3.14 : // 报错未定义</code></pre>
<h5 id="2-不允许删除变量、对象和函数。"><a href="#2-不允许删除变量、对象和函数。" class="headerlink" title="2.不允许删除变量、对象和函数。"></a>2.不允许删除变量、对象和函数。</h5><pre><code class="js">&#39;use strict&#39;;

var x = 3.15

delect x, // 错误

function x(p1, p2) &#123;&#125;;

delete x;                // 报错</code></pre>
<h5 id="3-不允许变量重名"><a href="#3-不允许变量重名" class="headerlink" title="3.不允许变量重名"></a>3.不允许变量重名</h5><pre><code class="js">&#39;use strict&#39;
function x(p1,p1)&#123;&#125;; // 报错</code></pre>
<h5 id="4-不允许使用8进制"><a href="#4-不允许使用8进制" class="headerlink" title="4.不允许使用8进制"></a>4.不允许使用8进制</h5><pre><code class="js">&#39;use strict&#39;
var x = 010; // 报错</code></pre>
<h5 id="5-不允许使用转义字符"><a href="#5-不允许使用转义字符" class="headerlink" title="5.不允许使用转义字符"></a>5.不允许使用转义字符</h5><pre><code class="js">&#39;use strict&#39;
var x = \010; //报错</code></pre>
<h5 id="6-不允许对只读属性赋值；"><a href="#6-不允许对只读属性赋值；" class="headerlink" title="6.不允许对只读属性赋值；"></a>6.不允许对只读属性赋值；</h5><pre><code class="js">&#39;use strict&#39;;
var obj = &#123;&#125;;
Object.defineProperty(obj,&#39;x&#39;,&#123;value:0,writable:false&#125;)
obj.x = 3.14 //报错</code></pre>
<h5 id="7-不允许删除一个不允许删除的属性"><a href="#7-不允许删除一个不允许删除的属性" class="headerlink" title="7.不允许删除一个不允许删除的属性"></a>7.不允许删除一个不允许删除的属性</h5><pre><code class="js">&#39;use strict&#39;
delete Object.proptotype //报错</code></pre>
<h5 id="8-变量名不能使用-“eval”-和-“arguments”字符串；"><a href="#8-变量名不能使用-“eval”-和-“arguments”字符串；" class="headerlink" title="8.变量名不能使用  “eval”  和 “arguments”字符串；"></a>8.变量名不能使用  “eval”  和 “arguments”字符串；</h5><pre><code class="js">&#39;use strict&#39;
var eval = 3.15; //报错
var arguments = 3.15 //报错</code></pre>
<h5 id="9-处于安全原因-作用域eval-创建的变量不能被调用"><a href="#9-处于安全原因-作用域eval-创建的变量不能被调用" class="headerlink" title="9.处于安全原因,作用域eval()创建的变量不能被调用"></a>9.处于安全原因,作用域eval()创建的变量不能被调用</h5><pre><code class="js">&#39;use strict&#39;
eval (&#39;var x = 3&#39;);
conaole.log(x) // 报错</code></pre>
<h5 id="10-禁止this关键字指向全局对象。"><a href="#10-禁止this关键字指向全局对象。" class="headerlink" title="10.禁止this关键字指向全局对象。"></a>10.禁止this关键字指向全局对象。</h5><pre><code class="js">//非严格模式
function f()&#123;
    return !this;
&#125; 
// 返回false,默认指向全局对象，！this就是false

&#39;use strict&#39;
function f()&#123;
    return this
&#125;
// 严格模式下，this的值默认为undefined ,!this就是true</code></pre>
<h5 id="11-严格模式保留字"><a href="#11-严格模式保留字" class="headerlink" title="11.严格模式保留字"></a>11.严格模式保留字</h5><ul>
<li>implements</li>
<li>interface</li>
<li>let</li>
<li>package</li>
<li>private</li>
<li>protected</li>
<li>public</li>
<li>static</li>
<li>yield</li>
</ul>
<pre><code class="js">&quot;use strict&quot;;
var public = 1500;      // 报错</code></pre>
]]></content>
  </entry>
  <entry>
    <title>同源及跨域</title>
    <url>/2021/01/11/%E5%90%8C%E6%BA%90%E5%8F%8A%E8%B7%A8%E5%9F%9F/</url>
    <content><![CDATA[<h3 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h3><ul>
<li>ajax 请求时，浏览器要求当前网页和server必须同源（安全）</li>
<li>同源：协议，域名，端口，三者必须一致</li>
</ul>
<blockquote>
<p><strong>同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。</strong></p>
</blockquote>
<h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><p>跨域，指的是从一个域名去请求另外一个域名的资源。即跨域名请求！跨域时，浏览器不能执行其他域名网站的脚本，是由浏览器的同源策略造成的，是浏览器施加的安全限制。</p>
<p>跨域的严格一点来说就是只要协议，域名，端口有任何一个的不同，就被当作是跨域。</p>
<h3 id="解决同源"><a href="#解决同源" class="headerlink" title="解决同源"></a>解决同源</h3><h5 id="加载图片-引用CSS-和-JS文件时-可无视同源策略"><a href="#加载图片-引用CSS-和-JS文件时-可无视同源策略" class="headerlink" title="加载图片 引用CSS 和 JS文件时 可无视同源策略"></a>加载图片 引用CSS 和 JS文件时 可无视同源策略</h5><ul>
<li><code>&lt;img src=&quot;跨域的图片地址&quot; /&gt;</code>  <strong>可用于统计打点，可使用第三方统计服务</strong></li>
<li><code>&lt;link href=&quot;跨域的css地址&quot; /&gt;</code> <strong>可使用CDN,CDN一般都是外域</strong></li>
<li><code>&lt;script src=&quot;跨域的js地址&quot;&gt;&lt;/script&gt;</code> <strong>可实现JSONP</strong></li>
</ul>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="1-JSONP"><a href="#1-JSONP" class="headerlink" title="1.  JSONP"></a>1.  JSONP</h4><h4 id="2-jquery-自带jsonp"><a href="#2-jquery-自带jsonp" class="headerlink" title="2. jquery 自带jsonp"></a>2. jquery 自带jsonp</h4>]]></content>
  </entry>
  <entry>
    <title>防抖与节流</title>
    <url>/2021/01/12/%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/</url>
    <content><![CDATA[<h3 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h3><p>思路  :  <strong>在第一次触发事件时，不立即执行函数，而是给出一个期限值比如200ms</strong>，然后：</p>
<ul>
<li>如果在200ms内没有再次触发滚动事件，那么就执行函数</li>
<li>如果在200ms内再次触发滚动事件，那么当前的计时取消，重新开始计时</li>
</ul>
<p><strong>效果</strong>：如果短时间内大量触发同一事件，只会执行一次函数。</p>
<p><strong>实现</strong>：既然前面都提到了计时，那实现的关键就在于<code>setTimeout</code>这个函数，由于还需要一个变量来保存计时，考虑维护全局纯净，可以借助闭包来实现：</p>
<pre><code class="js">function debounce(fn,delay)&#123;
    let timer = null //借助闭包
    return function() &#123;
        if(timer)&#123;
            clearTimeout(timer) 
        &#125;
        timer = setTimeout(fn,delay) // 简化写法
    &#125;
&#125;
function showTop  () &#123;
    var scrollTop = document.body.scrollTop || document.documentElement.scrollTop;
　　console.log(&#39;滚动条位置：&#39; + scrollTop);
&#125;
window.onscroll = debounce(showTop,1000)</code></pre>
<p>此时会发现，必须在停止滚动1秒以后，才会打印出滚动条位置。</p>
<p>到这里，已经把<strong>防抖</strong>实现了，现在给出定义：</p>
<ul>
<li>对于<strong>短时间内连续触发</strong>的事件（上面的滚动事件），<strong>防抖的含义就是让某个时间期限（如上面的1000毫秒）内，事件处理函数只执行一次。</strong></li>
</ul>
<h3 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h3><p>继续思考，使用上面的防抖方案来处理问题的结果是：</p>
<ul>
<li>如果在限定时间段内，不断触发滚动事件（比如某个用户闲着无聊，按住滚动不断的拖来拖去），只要不停止触发，理论上就永远不会输出当前距离顶部的距离。</li>
</ul>
<p><strong>但是如果产品同学的期望处理方案是：即使用户不断点击或拖动滚动条，也能在某个时间间隔之后给出反馈</strong></p>
<p>其实很简单：我们可以设计一种<strong>类似控制阀门一样定期开放的函数，也就是让函数执行一次后，在某个时间段内暂时失效，过了这段时间后再重新激活</strong>（类似于技能冷却时间）。</p>
<p><strong>效果</strong>：如果短时间内大量触发同一事件，那么<strong>在函数执行一次之后，该函数在指定的时间期限内不再工作</strong>，直至过了这段时间才重新生效。</p>
<p><strong>实现</strong> 这里借助<code>setTimeout</code>来做一个简单的实现，加上一个状态位<code>valid</code>来表示当前函数是否处于工作状态：</p>
<pre><code class="js">function throttle(fn,delay)&#123;
    let valid = true
    return function() &#123;
       if(!valid)&#123;
           //休息时间 暂不接客
           return false 
       &#125;
       // 工作时间，执行函数并且在间隔期内把状态位设为无效
        valid = false
        setTimeout(() =&gt; &#123;
            fn()
            valid = true;
        &#125;, delay)
    &#125;
&#125;
/* 请注意，节流函数并不止上面这种实现方案,
   例如可以完全不借助setTimeout，可以把状态位换成时间戳，然后利用时间戳差值是否大于指定间隔时间来做判定。
   也可以直接将setTimeout的返回的标记当做判断条件-判断当前定时器是否存在，如果存在表示还在冷却，并且在执行fn之后消除定时器表示激活，原理都一样
    */

// 以下照旧
function showTop  () &#123;
    var scrollTop = document.body.scrollTop || document.documentElement.scrollTop;
　　console.log(&#39;滚动条位置：&#39; + scrollTop);
&#125;
window.onscroll = throttle(showTop,1000) </code></pre>
<p>运行以上代码的结果是：</p>
<ul>
<li>如果一直拖着滚动条进行滚动，那么会以1s的时间间隔，持续输出当前位置和顶部的距离</li>
</ul>
<h3 id="上述内容基于防抖和节流的核心思路设计了简单的实现算法"><a href="#上述内容基于防抖和节流的核心思路设计了简单的实现算法" class="headerlink" title="上述内容基于防抖和节流的核心思路设计了简单的实现算法"></a>上述内容基于防抖和节流的核心思路设计了简单的实现算法</h3>]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>proxy</title>
    <url>/2021/01/25/proxy/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。</p>
<p>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</p>
<pre><code class="javascript">var obj = new Proxy(&#123;&#125;, &#123;
  get: function (target, propKey, receiver) &#123;
    console.log(`getting $&#123;propKey&#125;!`);
    return Reflect.get(target, propKey, receiver);
  &#125;,
  set: function (target, propKey, value, receiver) &#123;
    console.log(`setting $&#123;propKey&#125;!`);
    return Reflect.set(target, propKey, value, receiver);
  &#125;
&#125;);</code></pre>
<p>上面代码对一个空对象架设了一层拦截，重定义了属性的读取（<code>get</code>）和设置（<code>set</code>）行为。这里暂时先不解释具体的语法，只看运行结果。对设置了拦截行为的对象<code>obj</code>，去读写它的属性，就会得到下面的结果。</p>
<pre><code class="javascript">obj.count = 1
//  setting count!
++obj.count
//  getting count!
//  setting count!
//  2</code></pre>
<p>上面代码说明，Proxy 实际上重载（overload）了点运算符，即用自己的定义覆盖了语言的原始定义。</p>
<p>ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例。</p>
<pre><code class="javascript">var proxy = new Proxy(target, handler);</code></pre>
<p>Proxy 对象的所有用法，都是上面这种形式，不同的只是<code>handler</code>参数的写法。其中，<code>new Proxy()</code>表示生成一个<code>Proxy</code>实例，<code>target</code>参数表示所要拦截的目标对象，<code>handler</code>参数也是一个对象，用来定制拦截行为。</p>
<p>下面是另一个拦截读取属性行为的例子。</p>
<pre><code class="javascript">var proxy = new Proxy(&#123;&#125;, &#123;
  get: function(target, propKey) &#123;
    return 35;
  &#125;
&#125;);

proxy.time // 35
proxy.name // 35
proxy.title // 35</code></pre>
<p>上面代码中，作为构造函数，<code>Proxy</code>接受两个参数。第一个参数是所要代理的目标对象（上例是一个空对象），即如果没有<code>Proxy</code>的介入，操作原来要访问的就是这个对象；第二个参数是一个配置对象，对于每一个被代理的操作，需要提供一个对应的处理函数，该函数将拦截对应的操作。比如，上面代码中，配置对象有一个<code>get</code>方法，用来拦截对目标对象属性的访问请求。<code>get</code>方法的两个参数分别是目标对象和所要访问的属性。可以看到，由于拦截函数总是返回<code>35</code>，所以访问任何属性都得到<code>35</code>。</p>
<p>注意，要使得<code>Proxy</code>起作用，必须针对<code>Proxy</code>实例（上例是<code>proxy</code>对象）进行操作，而不是针对目标对象（上例是空对象）进行操作。</p>
<p>如果<code>handler</code>没有设置任何拦截，那就等同于直接通向原对象。</p>
<pre><code class="javascript">var target = &#123;&#125;;
var handler = &#123;&#125;;
var proxy = new Proxy(target, handler);
proxy.a = &#39;b&#39;;
target.a // &quot;b&quot;</code></pre>
<p>上面代码中，<code>handler</code>是一个空对象，没有任何拦截效果，访问<code>proxy</code>就等同于访问<code>target</code>。</p>
<p>一个技巧是将 Proxy 对象，设置到<code>object.proxy</code>属性，从而可以在<code>object</code>对象上调用。</p>
<pre><code class="javascript">var object = &#123; proxy: new Proxy(target, handler) &#125;;</code></pre>
<p>Proxy 实例也可以作为其他对象的原型对象。</p>
<pre><code class="javascript">var proxy = new Proxy(&#123;&#125;, &#123;
  get: function(target, propKey) &#123;
    return 35;
  &#125;
&#125;);

let obj = Object.create(proxy);
obj.time // 35</code></pre>
<p>上面代码中，<code>proxy</code>对象是<code>obj</code>对象的原型，<code>obj</code>对象本身并没有<code>time</code>属性，所以根据原型链，会在<code>proxy</code>对象上读取该属性，导致被拦截。</p>
<p>同一个拦截器函数，可以设置拦截多个操作。</p>
<pre><code class="javascript">var handler = &#123;
  get: function(target, name) &#123;
    if (name === &#39;prototype&#39;) &#123;
      return Object.prototype;
    &#125;
    return &#39;Hello, &#39; + name;
  &#125;,

  apply: function(target, thisBinding, args) &#123;
    return args[0];
  &#125;,

  construct: function(target, args) &#123;
    return &#123;value: args[1]&#125;;
  &#125;
&#125;;

var fproxy = new Proxy(function(x, y) &#123;
  return x + y;
&#125;, handler);

fproxy(1, 2) // 1
new fproxy(1, 2) // &#123;value: 2&#125;
fproxy.prototype === Object.prototype // true
fproxy.foo === &quot;Hello, foo&quot; // true</code></pre>
<p>对于可以设置、但没有设置拦截的操作，则直接落在目标对象上，按照原先的方式产生结果。</p>
<p>下面是 Proxy 支持的拦截操作一览，一共 13 种。</p>
<ul>
<li>get(target, propKey, receiver)：拦截对象属性的读取，比如proxy.foo和proxy[‘foo’]。</li>
<li>set(target, propKey, value, receiver)：拦截对象属性的设置，比如proxy.foo = v或proxy[‘foo’] = v，返回一个布尔值。</li>
<li>has(target, propKey)：拦截propKey in proxy的操作，返回一个布尔值。</li>
<li>deleteProperty(target, propKey)：拦截delete proxy[propKey]的操作，返回一个布尔值。</li>
<li>ownKeys(target)：拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for…in循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历属性。</li>
<li>getOwnPropertyDescriptor(target, propKey)：拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。</li>
<li>defineProperty(target, propKey, propDesc)：拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。</li>
<li>preventExtensions(target)：拦截Object.preventExtensions(proxy)，返回一个布尔值。</li>
<li>getPrototypeOf(target)：拦截Object.getPrototypeOf(proxy)，返回一个对象。</li>
<li>isExtensible(target)：拦截Object.isExtensible(proxy)，返回一个布尔值。</li>
<li>setPrototypeOf(target, proto)：拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。</li>
<li>apply(target, object, args)：拦截 Proxy 实例作为函数调用的操作，比如proxy(…args)、proxy.call(object, …args)、proxy.apply(…)。</li>
<li>construct(target, args)：拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(…args)。</li>
</ul>
<h2 id="Proxy-实例的方法"><a href="#Proxy-实例的方法" class="headerlink" title="Proxy 实例的方法"></a>Proxy 实例的方法</h2><p>下面是上面这些拦截方法的详细介绍。</p>
<h3 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h3><p><code>get</code>方法用于拦截某个属性的读取操作，可以接受三个参数，依次为目标对象、属性名和 proxy 实例本身（严格地说，是操作行为所针对的对象），其中最后一个参数可选。</p>
<p><code>get</code>方法的用法，上文已经有一个例子，下面是另一个拦截读取操作的例子。</p>
<pre><code class="javascript">var person = &#123;
  name: &quot;张三&quot;
&#125;;

var proxy = new Proxy(person, &#123;
  get: function(target, propKey) &#123;
    if (propKey in target) &#123;
      return target[propKey];
    &#125; else &#123;
      throw new ReferenceError(&quot;Prop name \&quot;&quot; + propKey + &quot;\&quot; does not exist.&quot;);
    &#125;
  &#125;
&#125;);

proxy.name // &quot;张三&quot;
proxy.age // 抛出一个错误</code></pre>
<p>上面代码表示，如果访问目标对象不存在的属性，会抛出一个错误。如果没有这个拦截函数，访问不存在的属性，只会返回<code>undefined</code>。</p>
<p><code>get</code>方法可以继承。</p>
<pre><code class="javascript">let proto = new Proxy(&#123;&#125;, &#123;
  get(target, propertyKey, receiver) &#123;
    console.log(&#39;GET &#39; + propertyKey);
    return target[propertyKey];
  &#125;
&#125;);

let obj = Object.create(proto);
obj.foo // &quot;GET foo&quot;</code></pre>
<p>上面代码中，拦截操作定义在<code>Prototype</code>对象上面，所以如果读取<code>obj</code>对象继承的属性时，拦截会生效。</p>
<p>下面的例子使用<code>get</code>拦截，实现数组读取负数的索引。</p>
<pre><code class="javascript">function createArray(...elements) &#123;
  let handler = &#123;
    get(target, propKey, receiver) &#123;
      let index = Number(propKey);
      if (index &lt; 0) &#123;
        propKey = String(target.length + index);
      &#125;
      return Reflect.get(target, propKey, receiver);
    &#125;
  &#125;;

  let target = [];
  target.push(...elements);
  return new Proxy(target, handler);
&#125;

let arr = createArray(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;);
arr[-1] // c</code></pre>
<p>上面代码中，数组的位置参数是<code>-1</code>，就会输出数组的倒数第一个成员。</p>
<p>利用 Proxy，可以将读取属性的操作（<code>get</code>），转变为执行某个函数，从而实现属性的链式操作。</p>
<pre><code class="javascript">var pipe = function (value) &#123;
  var funcStack = [];
  var oproxy = new Proxy(&#123;&#125; , &#123;
    get : function (pipeObject, fnName) &#123;
      if (fnName === &#39;get&#39;) &#123;
        return funcStack.reduce(function (val, fn) &#123;
          return fn(val);
        &#125;,value);
      &#125;
      funcStack.push(window[fnName]);
      return oproxy;
    &#125;
  &#125;);

  return oproxy;
&#125;

var double = n =&gt; n * 2;
var pow    = n =&gt; n * n;
var reverseInt = n =&gt; n.toString().split(&quot;&quot;).reverse().join(&quot;&quot;) | 0;

pipe(3).double.pow.reverseInt.get; // 63</code></pre>
<p>上面代码设置 Proxy 以后，达到了将函数名链式使用的效果。</p>
<p>下面的例子则是利用<code>get</code>拦截，实现一个生成各种 DOM 节点的通用函数<code>dom</code>。</p>
<pre><code class="javascript">const dom = new Proxy(&#123;&#125;, &#123;
  get(target, property) &#123;
    return function(attrs = &#123;&#125;, ...children) &#123;
      const el = document.createElement(property);
      for (let prop of Object.keys(attrs)) &#123;
        el.setAttribute(prop, attrs[prop]);
      &#125;
      for (let child of children) &#123;
        if (typeof child === &#39;string&#39;) &#123;
          child = document.createTextNode(child);
        &#125;
        el.appendChild(child);
      &#125;
      return el;
    &#125;
  &#125;
&#125;);

const el = dom.div(&#123;&#125;,
  &#39;Hello, my name is &#39;,
  dom.a(&#123;href: &#39;//example.com&#39;&#125;, &#39;Mark&#39;),
  &#39;. I like:&#39;,
  dom.ul(&#123;&#125;,
    dom.li(&#123;&#125;, &#39;The web&#39;),
    dom.li(&#123;&#125;, &#39;Food&#39;),
    dom.li(&#123;&#125;, &#39;…actually that\&#39;s it&#39;)
  )
);

document.body.appendChild(el);</code></pre>
<p>下面是一个<code>get</code>方法的第三个参数的例子，它总是指向原始的读操作所在的那个对象，一般情况下就是 Proxy 实例。</p>
<pre><code class="javascript">const proxy = new Proxy(&#123;&#125;, &#123;
  get: function(target, key, receiver) &#123;
    return receiver;
  &#125;
&#125;);
proxy.getReceiver === proxy // true</code></pre>
<p>上面代码中，<code>proxy</code>对象的<code>getReceiver</code>属性是由<code>proxy</code>对象提供的，所以<code>receiver</code>指向<code>proxy</code>对象。</p>
<pre><code class="javascript">const proxy = new Proxy(&#123;&#125;, &#123;
  get: function(target, key, receiver) &#123;
    return receiver;
  &#125;
&#125;);

const d = Object.create(proxy);
d.a === d // true</code></pre>
<p>上面代码中，<code>d</code>对象本身没有<code>a</code>属性，所以读取<code>d.a</code>的时候，会去<code>d</code>的原型<code>proxy</code>对象找。这时，<code>receiver</code>就指向<code>d</code>，代表原始的读操作所在的那个对象。</p>
<p>如果一个属性不可配置（configurable）且不可写（writable），则 Proxy 不能修改该属性，否则通过 Proxy 对象访问该属性会报错。</p>
<pre><code class="javascript">const target = Object.defineProperties(&#123;&#125;, &#123;
  foo: &#123;
    value: 123,
    writable: false,
    configurable: false
  &#125;,
&#125;);

const handler = &#123;
  get(target, propKey) &#123;
    return &#39;abc&#39;;
  &#125;
&#125;;

const proxy = new Proxy(target, handler);

proxy.foo
// TypeError: Invariant check failed</code></pre>
<h3 id="set"><a href="#set" class="headerlink" title="set()"></a>set()</h3><p><code>set</code>方法用来拦截某个属性的赋值操作，可以接受四个参数，依次为目标对象、属性名、属性值和 Proxy 实例本身，其中最后一个参数可选。</p>
<p>假定<code>Person</code>对象有一个<code>age</code>属性，该属性应该是一个不大于 200 的整数，那么可以使用<code>Proxy</code>保证<code>age</code>的属性值符合要求。</p>
<pre><code class="javascript">let validator = &#123;
  set: function(obj, prop, value) &#123;
    if (prop === &#39;age&#39;) &#123;
      if (!Number.isInteger(value)) &#123;
        throw new TypeError(&#39;The age is not an integer&#39;);
      &#125;
      if (value &gt; 200) &#123;
        throw new RangeError(&#39;The age seems invalid&#39;);
      &#125;
    &#125;

    // 对于满足条件的 age 属性以及其他属性，直接保存
    obj[prop] = value;
  &#125;
&#125;;

let person = new Proxy(&#123;&#125;, validator);

person.age = 100;

person.age // 100
person.age = &#39;young&#39; // 报错
person.age = 300 // 报错</code></pre>
<p>上面代码中，由于设置了存值函数<code>set</code>，任何不符合要求的<code>age</code>属性赋值，都会抛出一个错误，这是数据验证的一种实现方法。利用<code>set</code>方法，还可以数据绑定，即每当对象发生变化时，会自动更新 DOM。</p>
<p>有时，我们会在对象上面设置内部属性，属性名的第一个字符使用下划线开头，表示这些属性不应该被外部使用。结合<code>get</code>和<code>set</code>方法，就可以做到防止这些内部属性被外部读写。</p>
<pre><code class="javascript">const handler = &#123;
  get (target, key) &#123;
    invariant(key, &#39;get&#39;);
    return target[key];
  &#125;,
  set (target, key, value) &#123;
    invariant(key, &#39;set&#39;);
    target[key] = value;
    return true;
  &#125;
&#125;;
function invariant (key, action) &#123;
  if (key[0] === &#39;_&#39;) &#123;
    throw new Error(`Invalid attempt to $&#123;action&#125; private &quot;$&#123;key&#125;&quot; property`);
  &#125;
&#125;
const target = &#123;&#125;;
const proxy = new Proxy(target, handler);
proxy._prop
// Error: Invalid attempt to get private &quot;_prop&quot; property
proxy._prop = &#39;c&#39;
// Error: Invalid attempt to set private &quot;_prop&quot; property</code></pre>
<p>上面代码中，只要读写的属性名的第一个字符是下划线，一律抛错，从而达到禁止读写内部属性的目的。</p>
<p>下面是<code>set</code>方法第四个参数的例子。</p>
<pre><code class="javascript">const handler = &#123;
  set: function(obj, prop, value, receiver) &#123;
    obj[prop] = receiver;
  &#125;
&#125;;
const proxy = new Proxy(&#123;&#125;, handler);
proxy.foo = &#39;bar&#39;;
proxy.foo === proxy // true</code></pre>
<p>上面代码中，<code>set</code>方法的第四个参数<code>receiver</code>，指的是原始的操作行为所在的那个对象，一般情况下是<code>proxy</code>实例本身，请看下面的例子。</p>
<pre><code class="javascript">const handler = &#123;
  set: function(obj, prop, value, receiver) &#123;
    obj[prop] = receiver;
  &#125;
&#125;;
const proxy = new Proxy(&#123;&#125;, handler);
const myObj = &#123;&#125;;
Object.setPrototypeOf(myObj, proxy);

myObj.foo = &#39;bar&#39;;
myObj.foo === myObj // true</code></pre>
<p>上面代码中，设置<code>myObj.foo</code>属性的值时，<code>myObj</code>并没有<code>foo</code>属性，因此引擎会到<code>myObj</code>的原型链去找<code>foo</code>属性。<code>myObj</code>的原型对象<code>proxy</code>是一个 Proxy 实例，设置它的<code>foo</code>属性会触发<code>set</code>方法。这时，第四个参数<code>receiver</code>就指向原始赋值行为所在的对象<code>myObj</code>。</p>
<p>注意，如果目标对象自身的某个属性不可写，那么<code>set</code>方法将不起作用。</p>
<pre><code class="javascript">const obj = &#123;&#125;;
Object.defineProperty(obj, &#39;foo&#39;, &#123;
  value: &#39;bar&#39;,
  writable: false
&#125;);

const handler = &#123;
  set: function(obj, prop, value, receiver) &#123;
    obj[prop] = &#39;baz&#39;;
  &#125;
&#125;;

const proxy = new Proxy(obj, handler);
proxy.foo = &#39;baz&#39;;
proxy.foo // &quot;bar&quot;</code></pre>
<p>上面代码中，<code>obj.foo</code>属性不可写，Proxy 对这个属性的<code>set</code>代理将不会生效。</p>
<p>注意，严格模式下，<code>set</code>代理如果没有返回<code>true</code>，就会报错。</p>
<pre><code class="javascript">&#39;use strict&#39;;
const handler = &#123;
  set: function(obj, prop, value, receiver) &#123;
    obj[prop] = receiver;
    // 无论有没有下面这一行，都会报错
    return false;
  &#125;
&#125;;
const proxy = new Proxy(&#123;&#125;, handler);
proxy.foo = &#39;bar&#39;;
// TypeError: &#39;set&#39; on proxy: trap returned falsish for property &#39;foo&#39;</code></pre>
<p>上面代码中，严格模式下，<code>set</code>代理返回<code>false</code>或者<code>undefined</code>，都会报错。</p>
<h3 id="apply"><a href="#apply" class="headerlink" title="apply()"></a>apply()</h3><p><code>apply</code>方法拦截函数的调用、<code>call</code>和<code>apply</code>操作。</p>
<p><code>apply</code>方法可以接受三个参数，分别是目标对象、目标对象的上下文对象（<code>this</code>）和目标对象的参数数组。</p>
<pre><code class="javascript">var handler = &#123;
  apply (target, ctx, args) &#123;
    return Reflect.apply(...arguments);
  &#125;
&#125;;</code></pre>
<p>下面是一个例子。</p>
<pre><code class="javascript">var target = function () &#123; return &#39;I am the target&#39;; &#125;;
var handler = &#123;
  apply: function () &#123;
    return &#39;I am the proxy&#39;;
  &#125;
&#125;;

var p = new Proxy(target, handler);

p()
// &quot;I am the proxy&quot;</code></pre>
<p>上面代码中，变量<code>p</code>是 Proxy 的实例，当它作为函数调用时（<code>p()</code>），就会被<code>apply</code>方法拦截，返回一个字符串。</p>
<p>下面是另外一个例子。</p>
<pre><code class="javascript">var twice = &#123;
  apply (target, ctx, args) &#123;
    return Reflect.apply(...arguments) * 2;
  &#125;
&#125;;
function sum (left, right) &#123;
  return left + right;
&#125;;
var proxy = new Proxy(sum, twice);
proxy(1, 2) // 6
proxy.call(null, 5, 6) // 22
proxy.apply(null, [7, 8]) // 30</code></pre>
<p>上面代码中，每当执行<code>proxy</code>函数（直接调用或<code>call</code>和<code>apply</code>调用），就会被<code>apply</code>方法拦截。</p>
<p>另外，直接调用<code>Reflect.apply</code>方法，也会被拦截。</p>
<pre><code class="javascript">Reflect.apply(proxy, null, [9, 10]) // 38</code></pre>
<h3 id="has"><a href="#has" class="headerlink" title="has()"></a>has()</h3><p><code>has()</code>方法用来拦截<code>HasProperty</code>操作，即判断对象是否具有某个属性时，这个方法会生效。典型的操作就是<code>in</code>运算符。</p>
<p><code>has()</code>方法可以接受两个参数，分别是目标对象、需查询的属性名。</p>
<p>下面的例子使用<code>has()</code>方法隐藏某些属性，不被<code>in</code>运算符发现。</p>
<pre><code class="javascript">var handler = &#123;
  has (target, key) &#123;
    if (key[0] === &#39;_&#39;) &#123;
      return false;
    &#125;
    return key in target;
  &#125;
&#125;;
var target = &#123; _prop: &#39;foo&#39;, prop: &#39;foo&#39; &#125;;
var proxy = new Proxy(target, handler);
&#39;_prop&#39; in proxy // false</code></pre>
<p>上面代码中，如果原对象的属性名的第一个字符是下划线，<code>proxy.has()</code>就会返回<code>false</code>，从而不会被<code>in</code>运算符发现。</p>
<p>如果原对象不可配置或者禁止扩展，这时<code>has()</code>拦截会报错。</p>
<pre><code class="javascript">var obj = &#123; a: 10 &#125;;
Object.preventExtensions(obj);

var p = new Proxy(obj, &#123;
  has: function(target, prop) &#123;
    return false;
  &#125;
&#125;);

&#39;a&#39; in p // TypeError is thrown</code></pre>
<p>上面代码中，<code>obj</code>对象禁止扩展，结果使用<code>has</code>拦截就会报错。也就是说，如果某个属性不可配置（或者目标对象不可扩展），则<code>has()</code>方法就不得“隐藏”（即返回<code>false</code>）目标对象的该属性。</p>
<p>值得注意的是，<code>has()</code>方法拦截的是<code>HasProperty</code>操作，而不是<code>HasOwnProperty</code>操作，即<code>has()</code>方法不判断一个属性是对象自身的属性，还是继承的属性。</p>
<p>另外，虽然<code>for...in</code>循环也用到了<code>in</code>运算符，但是<code>has()</code>拦截对<code>for...in</code>循环不生效。</p>
<pre><code class="javascript">let stu1 = &#123;name: &#39;张三&#39;, score: 59&#125;;
let stu2 = &#123;name: &#39;李四&#39;, score: 99&#125;;

let handler = &#123;
  has(target, prop) &#123;
    if (prop === &#39;score&#39; &amp;&amp; target[prop] &lt; 60) &#123;
      console.log(`$&#123;target.name&#125; 不及格`);
      return false;
    &#125;
    return prop in target;
  &#125;
&#125;

let oproxy1 = new Proxy(stu1, handler);
let oproxy2 = new Proxy(stu2, handler);

&#39;score&#39; in oproxy1
// 张三 不及格
// false

&#39;score&#39; in oproxy2
// true

for (let a in oproxy1) &#123;
  console.log(oproxy1[a]);
&#125;
// 张三
// 59

for (let b in oproxy2) &#123;
  console.log(oproxy2[b]);
&#125;
// 李四
// 99</code></pre>
<p>上面代码中，<code>has()</code>拦截只对<code>in</code>运算符生效，对<code>for...in</code>循环不生效，导致不符合要求的属性没有被<code>for...in</code>循环所排除。</p>
<h3 id="construct"><a href="#construct" class="headerlink" title="construct()"></a>construct()</h3><p><code>construct()</code>方法用于拦截<code>new</code>命令，下面是拦截对象的写法。</p>
<pre><code class="javascript">const handler = &#123;
  construct (target, args, newTarget) &#123;
    return new target(...args);
  &#125;
&#125;;</code></pre>
<p><code>construct()</code>方法可以接受三个参数。</p>
<ul>
<li><code>target</code>：目标对象。</li>
<li><code>args</code>：构造函数的参数数组。</li>
<li><code>newTarget</code>：创造实例对象时，<code>new</code>命令作用的构造函数（下面例子的<code>p</code>）。</li>
</ul>
<pre><code class="javascript">const p = new Proxy(function () &#123;&#125;, &#123;
  construct: function(target, args) &#123;
    console.log(&#39;called: &#39; + args.join(&#39;, &#39;));
    return &#123; value: args[0] * 10 &#125;;
  &#125;
&#125;);

(new p(1)).value
// &quot;called: 1&quot;
// 10</code></pre>
<p><code>construct()</code>方法返回的必须是一个对象，否则会报错。</p>
<pre><code class="javascript">const p = new Proxy(function() &#123;&#125;, &#123;
  construct: function(target, argumentsList) &#123;
    return 1;
  &#125;
&#125;);

new p() // 报错
// Uncaught TypeError: &#39;construct&#39; on proxy: trap returned non-object (&#39;1&#39;)</code></pre>
<p>另外，由于<code>construct()</code>拦截的是构造函数，所以它的目标对象必须是函数，否则就会报错。</p>
<pre><code class="javascript">const p = new Proxy(&#123;&#125;, &#123;
  construct: function(target, argumentsList) &#123;
    return &#123;&#125;;
  &#125;
&#125;);

new p() // 报错
// Uncaught TypeError: p is not a constructor</code></pre>
<p>上面例子中，拦截的目标对象不是一个函数，而是一个对象（<code>new Proxy()</code>的第一个参数），导致报错。</p>
<p>注意，<code>construct()</code>方法中的<code>this</code>指向的是<code>handler</code>，而不是实例对象。</p>
<pre><code class="javascript">const handler = &#123;
  construct: function(target, args) &#123;
    console.log(this === handler);
    return new target(...args);
  &#125;
&#125;

let p = new Proxy(function () &#123;&#125;, handler);
new p() // true</code></pre>
<h3 id="deleteProperty"><a href="#deleteProperty" class="headerlink" title="deleteProperty()"></a>deleteProperty()</h3><p><code>deleteProperty</code>方法用于拦截<code>delete</code>操作，如果这个方法抛出错误或者返回<code>false</code>，当前属性就无法被<code>delete</code>命令删除。</p>
<pre><code class="javascript">var handler = &#123;
  deleteProperty (target, key) &#123;
    invariant(key, &#39;delete&#39;);
    delete target[key];
    return true;
  &#125;
&#125;;
function invariant (key, action) &#123;
  if (key[0] === &#39;_&#39;) &#123;
    throw new Error(`Invalid attempt to $&#123;action&#125; private &quot;$&#123;key&#125;&quot; property`);
  &#125;
&#125;

var target = &#123; _prop: &#39;foo&#39; &#125;;
var proxy = new Proxy(target, handler);
delete proxy._prop
// Error: Invalid attempt to delete private &quot;_prop&quot; property</code></pre>
<p>上面代码中，<code>deleteProperty</code>方法拦截了<code>delete</code>操作符，删除第一个字符为下划线的属性会报错。</p>
<p>注意，目标对象自身的不可配置（configurable）的属性，不能被<code>deleteProperty</code>方法删除，否则报错。</p>
<h3 id="defineProperty"><a href="#defineProperty" class="headerlink" title="defineProperty()"></a>defineProperty()</h3><p><code>defineProperty()</code>方法拦截了<code>Object.defineProperty()</code>操作。</p>
<pre><code class="javascript">var handler = &#123;
  defineProperty (target, key, descriptor) &#123;
    return false;
  &#125;
&#125;;
var target = &#123;&#125;;
var proxy = new Proxy(target, handler);
proxy.foo = &#39;bar&#39; // 不会生效</code></pre>
<p>上面代码中，<code>defineProperty()</code>方法内部没有任何操作，只返回<code>false</code>，导致添加新属性总是无效。注意，这里的<code>false</code>只是用来提示操作失败，本身并不能阻止添加新属性。</p>
<p>注意，如果目标对象不可扩展（non-extensible），则<code>defineProperty()</code>不能增加目标对象上不存在的属性，否则会报错。另外，如果目标对象的某个属性不可写（writable）或不可配置（configurable），则<code>defineProperty()</code>方法不得改变这两个设置。</p>
<h3 id="getOwnPropertyDescriptor"><a href="#getOwnPropertyDescriptor" class="headerlink" title="getOwnPropertyDescriptor()"></a>getOwnPropertyDescriptor()</h3><p><code>getOwnPropertyDescriptor()</code>方法拦截<code>Object.getOwnPropertyDescriptor()</code>，返回一个属性描述对象或者<code>undefined</code>。</p>
<pre><code class="javascript">var handler = &#123;
  getOwnPropertyDescriptor (target, key) &#123;
    if (key[0] === &#39;_&#39;) &#123;
      return;
    &#125;
    return Object.getOwnPropertyDescriptor(target, key);
  &#125;
&#125;;
var target = &#123; _foo: &#39;bar&#39;, baz: &#39;tar&#39; &#125;;
var proxy = new Proxy(target, handler);
Object.getOwnPropertyDescriptor(proxy, &#39;wat&#39;)
// undefined
Object.getOwnPropertyDescriptor(proxy, &#39;_foo&#39;)
// undefined
Object.getOwnPropertyDescriptor(proxy, &#39;baz&#39;)
// &#123; value: &#39;tar&#39;, writable: true, enumerable: true, configurable: true &#125;</code></pre>
<p>上面代码中，<code>handler.getOwnPropertyDescriptor()</code>方法对于第一个字符为下划线的属性名会返回<code>undefined</code>。</p>
<h3 id="getPrototypeOf"><a href="#getPrototypeOf" class="headerlink" title="getPrototypeOf()"></a>getPrototypeOf()</h3><p><code>getPrototypeOf()</code>方法主要用来拦截获取对象原型。具体来说，拦截下面这些操作。</p>
<ul>
<li><code>Object.prototype.__proto__</code></li>
<li><code>Object.prototype.isPrototypeOf()</code></li>
<li><code>Object.getPrototypeOf()</code></li>
<li><code>Reflect.getPrototypeOf()</code></li>
<li><code>instanceof</code></li>
</ul>
<p>下面是一个例子。</p>
<pre><code class="javascript">var proto = &#123;&#125;;
var p = new Proxy(&#123;&#125;, &#123;
  getPrototypeOf(target) &#123;
    return proto;
  &#125;
&#125;);
Object.getPrototypeOf(p) === proto // true</code></pre>
<p>上面代码中，<code>getPrototypeOf()</code>方法拦截<code>Object.getPrototypeOf()</code>，返回<code>proto</code>对象。</p>
<p>注意，<code>getPrototypeOf()</code>方法的返回值必须是对象或者<code>null</code>，否则报错。另外，如果目标对象不可扩展（non-extensible）， <code>getPrototypeOf()</code>方法必须返回目标对象的原型对象。</p>
<h3 id="isExtensible"><a href="#isExtensible" class="headerlink" title="isExtensible()"></a>isExtensible()</h3><p><code>isExtensible()</code>方法拦截<code>Object.isExtensible()</code>操作。</p>
<pre><code class="javascript">var p = new Proxy(&#123;&#125;, &#123;
  isExtensible: function(target) &#123;
    console.log(&quot;called&quot;);
    return true;
  &#125;
&#125;);

Object.isExtensible(p)
// &quot;called&quot;
// true</code></pre>
<p>上面代码设置了<code>isExtensible()</code>方法，在调用<code>Object.isExtensible</code>时会输出<code>called</code>。</p>
<p>注意，该方法只能返回布尔值，否则返回值会被自动转为布尔值。</p>
<p>这个方法有一个强限制，它的返回值必须与目标对象的<code>isExtensible</code>属性保持一致，否则就会抛出错误。</p>
<pre><code class="javascript">Object.isExtensible(proxy) === Object.isExtensible(target)</code></pre>
<p>下面是一个例子。</p>
<pre><code class="javascript">var p = new Proxy(&#123;&#125;, &#123;
  isExtensible: function(target) &#123;
    return false;
  &#125;
&#125;);

Object.isExtensible(p)
// Uncaught TypeError: &#39;isExtensible&#39; on proxy: trap result does not reflect extensibility of proxy target (which is &#39;true&#39;)</code></pre>
<h3 id="ownKeys"><a href="#ownKeys" class="headerlink" title="ownKeys()"></a>ownKeys()</h3><p><code>ownKeys()</code>方法用来拦截对象自身属性的读取操作。具体来说，拦截以下操作。</p>
<ul>
<li><code>Object.getOwnPropertyNames()</code></li>
<li><code>Object.getOwnPropertySymbols()</code></li>
<li><code>Object.keys()</code></li>
<li><code>for...in</code>循环</li>
</ul>
<p>下面是拦截<code>Object.keys()</code>的例子。</p>
<pre><code class="javascript">let target = &#123;
  a: 1,
  b: 2,
  c: 3
&#125;;

let handler = &#123;
  ownKeys(target) &#123;
    return [&#39;a&#39;];
  &#125;
&#125;;

let proxy = new Proxy(target, handler);

Object.keys(proxy)
// [ &#39;a&#39; ]</code></pre>
<p>上面代码拦截了对于<code>target</code>对象的<code>Object.keys()</code>操作，只返回<code>a</code>、<code>b</code>、<code>c</code>三个属性之中的<code>a</code>属性。</p>
<p>下面的例子是拦截第一个字符为下划线的属性名。</p>
<pre><code class="javascript">let target = &#123;
  _bar: &#39;foo&#39;,
  _prop: &#39;bar&#39;,
  prop: &#39;baz&#39;
&#125;;

let handler = &#123;
  ownKeys (target) &#123;
    return Reflect.ownKeys(target).filter(key =&gt; key[0] !== &#39;_&#39;);
  &#125;
&#125;;

let proxy = new Proxy(target, handler);
for (let key of Object.keys(proxy)) &#123;
  console.log(target[key]);
&#125;
// &quot;baz&quot;</code></pre>
<p>注意，使用<code>Object.keys()</code>方法时，有三类属性会被<code>ownKeys()</code>方法自动过滤，不会返回。</p>
<ul>
<li>目标对象上不存在的属性</li>
<li>属性名为 Symbol 值</li>
<li>不可遍历（<code>enumerable</code>）的属性</li>
</ul>
<pre><code class="javascript">let target = &#123;
  a: 1,
  b: 2,
  c: 3,
  [Symbol.for(&#39;secret&#39;)]: &#39;4&#39;,
&#125;;

Object.defineProperty(target, &#39;key&#39;, &#123;
  enumerable: false,
  configurable: true,
  writable: true,
  value: &#39;static&#39;
&#125;);

let handler = &#123;
  ownKeys(target) &#123;
    return [&#39;a&#39;, &#39;d&#39;, Symbol.for(&#39;secret&#39;), &#39;key&#39;];
  &#125;
&#125;;

let proxy = new Proxy(target, handler);

Object.keys(proxy)
// [&#39;a&#39;]</code></pre>
<p>上面代码中，<code>ownKeys()</code>方法之中，显式返回不存在的属性（<code>d</code>）、Symbol 值（<code>Symbol.for(&#39;secret&#39;)</code>）、不可遍历的属性（<code>key</code>），结果都被自动过滤掉。</p>
<p><code>ownKeys()</code>方法还可以拦截<code>Object.getOwnPropertyNames()</code>。</p>
<pre><code class="javascript">var p = new Proxy(&#123;&#125;, &#123;
  ownKeys: function(target) &#123;
    return [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];
  &#125;
&#125;);

Object.getOwnPropertyNames(p)
// [ &#39;a&#39;, &#39;b&#39;, &#39;c&#39; ]</code></pre>
<p><code>for...in</code>循环也受到<code>ownKeys()</code>方法的拦截。</p>
<pre><code class="javascript">const obj = &#123; hello: &#39;world&#39; &#125;;
const proxy = new Proxy(obj, &#123;
  ownKeys: function () &#123;
    return [&#39;a&#39;, &#39;b&#39;];
  &#125;
&#125;);

for (let key in proxy) &#123;
  console.log(key); // 没有任何输出
&#125;</code></pre>
<p>上面代码中，<code>ownkeys()</code>指定只返回<code>a</code>和<code>b</code>属性，由于<code>obj</code>没有这两个属性，因此<code>for...in</code>循环不会有任何输出。</p>
<p><code>ownKeys()</code>方法返回的数组成员，只能是字符串或 Symbol 值。如果有其他类型的值，或者返回的根本不是数组，就会报错。</p>
<pre><code class="javascript">var obj = &#123;&#125;;

var p = new Proxy(obj, &#123;
  ownKeys: function(target) &#123;
    return [123, true, undefined, null, &#123;&#125;, []];
  &#125;
&#125;);

Object.getOwnPropertyNames(p)
// Uncaught TypeError: 123 is not a valid property name</code></pre>
<p>上面代码中，<code>ownKeys()</code>方法虽然返回一个数组，但是每一个数组成员都不是字符串或 Symbol 值，因此就报错了。</p>
<p>如果目标对象自身包含不可配置的属性，则该属性必须被<code>ownKeys()</code>方法返回，否则报错。</p>
<pre><code class="javascript">var obj = &#123;&#125;;
Object.defineProperty(obj, &#39;a&#39;, &#123;
  configurable: false,
  enumerable: true,
  value: 10 &#125;
);

var p = new Proxy(obj, &#123;
  ownKeys: function(target) &#123;
    return [&#39;b&#39;];
  &#125;
&#125;);

Object.getOwnPropertyNames(p)
// Uncaught TypeError: &#39;ownKeys&#39; on proxy: trap result did not include &#39;a&#39;</code></pre>
<p>上面代码中，<code>obj</code>对象的<code>a</code>属性是不可配置的，这时<code>ownKeys()</code>方法返回的数组之中，必须包含<code>a</code>，否则会报错。</p>
<p>另外，如果目标对象是不可扩展的（non-extensible），这时<code>ownKeys()</code>方法返回的数组之中，必须包含原对象的所有属性，且不能包含多余的属性，否则报错。</p>
<pre><code class="javascript">var obj = &#123;
  a: 1
&#125;;

Object.preventExtensions(obj);

var p = new Proxy(obj, &#123;
  ownKeys: function(target) &#123;
    return [&#39;a&#39;, &#39;b&#39;];
  &#125;
&#125;);

Object.getOwnPropertyNames(p)
// Uncaught TypeError: &#39;ownKeys&#39; on proxy: trap returned extra keys but proxy target is non-extensible</code></pre>
<p>上面代码中，<code>obj</code>对象是不可扩展的，这时<code>ownKeys()</code>方法返回的数组之中，包含了<code>obj</code>对象的多余属性<code>b</code>，所以导致了报错。</p>
<h3 id="preventExtensions"><a href="#preventExtensions" class="headerlink" title="preventExtensions()"></a>preventExtensions()</h3><p><code>preventExtensions()</code>方法拦截<code>Object.preventExtensions()</code>。该方法必须返回一个布尔值，否则会被自动转为布尔值。</p>
<p>这个方法有一个限制，只有目标对象不可扩展时（即<code>Object.isExtensible(proxy)</code>为<code>false</code>），<code>proxy.preventExtensions</code>才能返回<code>true</code>，否则会报错。</p>
<pre><code class="javascript">var proxy = new Proxy(&#123;&#125;, &#123;
  preventExtensions: function(target) &#123;
    return true;
  &#125;
&#125;);

Object.preventExtensions(proxy)
// Uncaught TypeError: &#39;preventExtensions&#39; on proxy: trap returned truish but the proxy target is extensible</code></pre>
<p>上面代码中，<code>proxy.preventExtensions()</code>方法返回<code>true</code>，但这时<code>Object.isExtensible(proxy)</code>会返回<code>true</code>，因此报错。</p>
<p>为了防止出现这个问题，通常要在<code>proxy.preventExtensions()</code>方法里面，调用一次<code>Object.preventExtensions()</code>。</p>
<pre><code class="javascript">var proxy = new Proxy(&#123;&#125;, &#123;
  preventExtensions: function(target) &#123;
    console.log(&#39;called&#39;);
    Object.preventExtensions(target);
    return true;
  &#125;
&#125;);

Object.preventExtensions(proxy)
// &quot;called&quot;
// Proxy &#123;&#125;</code></pre>
<h3 id="setPrototypeOf"><a href="#setPrototypeOf" class="headerlink" title="setPrototypeOf()"></a>setPrototypeOf()</h3><p><code>setPrototypeOf()</code>方法主要用来拦截<code>Object.setPrototypeOf()</code>方法。</p>
<p>下面是一个例子。</p>
<pre><code class="javascript">var handler = &#123;
  setPrototypeOf (target, proto) &#123;
    throw new Error(&#39;Changing the prototype is forbidden&#39;);
  &#125;
&#125;;
var proto = &#123;&#125;;
var target = function () &#123;&#125;;
var proxy = new Proxy(target, handler);
Object.setPrototypeOf(proxy, proto);
// Error: Changing the prototype is forbidden</code></pre>
<p>上面代码中，只要修改<code>target</code>的原型对象，就会报错。</p>
<p>注意，该方法只能返回布尔值，否则会被自动转为布尔值。另外，如果目标对象不可扩展（non-extensible），<code>setPrototypeOf()</code>方法不得改变目标对象的原型。</p>
<h2 id="Proxy-revocable"><a href="#Proxy-revocable" class="headerlink" title="Proxy.revocable()"></a>Proxy.revocable()</h2><p><code>Proxy.revocable()</code>方法返回一个可取消的 Proxy 实例。</p>
<pre><code class="javascript">let target = &#123;&#125;;
let handler = &#123;&#125;;

let &#123;proxy, revoke&#125; = Proxy.revocable(target, handler);

proxy.foo = 123;
proxy.foo // 123

revoke();
proxy.foo // TypeError: Revoked</code></pre>
<p><code>Proxy.revocable()</code>方法返回一个对象，该对象的<code>proxy</code>属性是<code>Proxy</code>实例，<code>revoke</code>属性是一个函数，可以取消<code>Proxy</code>实例。上面代码中，当执行<code>revoke</code>函数之后，再访问<code>Proxy</code>实例，就会抛出一个错误。</p>
<p><code>Proxy.revocable()</code>的一个使用场景是，目标对象不允许直接访问，必须通过代理访问，一旦访问结束，就收回代理权，不允许再次访问。</p>
<h2 id="this-问题"><a href="#this-问题" class="headerlink" title="this 问题"></a>this 问题</h2><p>虽然 Proxy 可以代理针对目标对象的访问，但它不是目标对象的透明代理，即不做任何拦截的情况下，也无法保证与目标对象的行为一致。主要原因就是在 Proxy 代理的情况下，目标对象内部的<code>this</code>关键字会指向 Proxy 代理。</p>
<pre><code class="javascript">const target = &#123;
  m: function () &#123;
    console.log(this === proxy);
  &#125;
&#125;;
const handler = &#123;&#125;;

const proxy = new Proxy(target, handler);

target.m() // false
proxy.m()  // true</code></pre>
<p>上面代码中，一旦<code>proxy</code>代理<code>target</code>，<code>target.m()</code>内部的<code>this</code>就是指向<code>proxy</code>，而不是<code>target</code>。</p>
<p>下面是一个例子，由于<code>this</code>指向的变化，导致 Proxy 无法代理目标对象。</p>
<pre><code class="javascript">const _name = new WeakMap();

class Person &#123;
  constructor(name) &#123;
    _name.set(this, name);
  &#125;
  get name() &#123;
    return _name.get(this);
  &#125;
&#125;

const jane = new Person(&#39;Jane&#39;);
jane.name // &#39;Jane&#39;

const proxy = new Proxy(jane, &#123;&#125;);
proxy.name // undefined</code></pre>
<p>上面代码中，目标对象<code>jane</code>的<code>name</code>属性，实际保存在外部<code>WeakMap</code>对象<code>_name</code>上面，通过<code>this</code>键区分。由于通过<code>proxy.name</code>访问时，<code>this</code>指向<code>proxy</code>，导致无法取到值，所以返回<code>undefined</code>。</p>
<p>此外，有些原生对象的内部属性，只有通过正确的<code>this</code>才能拿到，所以 Proxy 也无法代理这些原生对象的属性。</p>
<pre><code class="javascript">const target = new Date();
const handler = &#123;&#125;;
const proxy = new Proxy(target, handler);

proxy.getDate();
// TypeError: this is not a Date object.</code></pre>
<p>上面代码中，<code>getDate()</code>方法只能在<code>Date</code>对象实例上面拿到，如果<code>this</code>不是<code>Date</code>对象实例就会报错。这时，<code>this</code>绑定原始对象，就可以解决这个问题。</p>
<pre><code class="javascript">const target = new Date(&#39;2015-01-01&#39;);
const handler = &#123;
  get(target, prop) &#123;
    if (prop === &#39;getDate&#39;) &#123;
      return target.getDate.bind(target);
    &#125;
    return Reflect.get(target, prop);
  &#125;
&#125;;
const proxy = new Proxy(target, handler);

proxy.getDate() // 1</code></pre>
<p>另外，Proxy 拦截函数内部的<code>this</code>，指向的是<code>handler</code>对象。</p>
<pre><code class="javascript">const handler = &#123;
  get: function (target, key, receiver) &#123;
    console.log(this === handler);
    return &#39;Hello, &#39; + key;
  &#125;,
  set: function (target, key, value) &#123;
    console.log(this === handler);
    target[key] = value;
    return true;
  &#125;
&#125;;

const proxy = new Proxy(&#123;&#125;, handler);

proxy.foo
// true
// Hello, foo

proxy.foo = 1
// true</code></pre>
<p>上面例子中，<code>get()</code>和<code>set()</code>拦截函数内部的<code>this</code>，指向的都是<code>handler</code>对象。</p>
<h2 id="实例：Web-服务的客户端"><a href="#实例：Web-服务的客户端" class="headerlink" title="实例：Web 服务的客户端"></a>实例：Web 服务的客户端</h2><p>Proxy 对象可以拦截目标对象的任意属性，这使得它很合适用来写 Web 服务的客户端。</p>
<pre><code class="javascript">const service = createWebService(&#39;http://example.com/data&#39;);

service.employees().then(json =&gt; &#123;
  const employees = JSON.parse(json);
  // ···
&#125;);</code></pre>
<p>上面代码新建了一个 Web 服务的接口，这个接口返回各种数据。Proxy 可以拦截这个对象的任意属性，所以不用为每一种数据写一个适配方法，只要写一个 Proxy 拦截就可以了。</p>
<pre><code class="javascript">function createWebService(baseUrl) &#123;
  return new Proxy(&#123;&#125;, &#123;
    get(target, propKey, receiver) &#123;
      return () =&gt; httpGet(baseUrl + &#39;/&#39; + propKey);
    &#125;
  &#125;);
&#125;</code></pre>
<p>同理，Proxy 也可以用来实现数据库的 ORM 层。</p>
]]></content>
      <tags>
        <tag>proxy代理</tag>
      </tags>
  </entry>
</search>

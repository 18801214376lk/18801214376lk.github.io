<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2020/12/25/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>TypeScript</title>
    <url>/2021/01/04/Object/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>TypeScript</title>
    <url>/2020/12/30/TypeScript/</url>
    <content><![CDATA[<h3 id="1-基础类型"><a href="#1-基础类型" class="headerlink" title="1.基础类型"></a>1.基础类型</h3><p><strong>为了让程序有价值，我们需要能够处理最简单的数据单元：数字，字符串，结构体，布尔值等。TypeScript支持与javaScript几乎相同的数据类型，此外还提供了实用的的枚举类型方便我们使用。</strong></p>
<h4 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h4>]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>class的总结</title>
    <url>/2020/12/28/class/</url>
    <content><![CDATA[<h3 id="js语言中，生成实例对象的传统方法是构造函数"><a href="#js语言中，生成实例对象的传统方法是构造函数" class="headerlink" title="js语言中，生成实例对象的传统方法是构造函数"></a>js语言中，生成实例对象的传统方法是构造函数</h3><pre><code>function Point(x, y) &#123;
  this.x = x;
  this.y = y;
&#125;

Point.prototype.toString = function () &#123;
  return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;;
&#125;;

var p = new Point(1, 2);</code></pre>
<h3 id="ES6-提供了更接近传统语言的写法，引入了-Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。"><a href="#ES6-提供了更接近传统语言的写法，引入了-Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。" class="headerlink" title="ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。"></a>ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。</h3><h3 id="改写-同上"><a href="#改写-同上" class="headerlink" title="改写,同上"></a>改写,同上</h3><pre><code>class Point &#123;
  constructor(x, y) &#123;
    this.x = x;
    this.y = y;
  &#125;

  toString() &#123;
    return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;;
  &#125;
&#125;</code></pre>
<h3 id="class-类有一个constructor方法，这就是构造方法-就算你不调用也会执行-this则代表了实例对象。"><a href="#class-类有一个constructor方法，这就是构造方法-就算你不调用也会执行-this则代表了实例对象。" class="headerlink" title="class 类有一个constructor方法，这就是构造方法,(就算你不调用也会执行) this则代表了实例对象。"></a>class 类有一个constructor方法，这就是构造方法,(就算你不调用也会执行) this则代表了实例对象。</h3><h3 id="定义类方法不需要function关键字-Point也不是对象-各个方法之间也不需要用’-’隔开。"><a href="#定义类方法不需要function关键字-Point也不是对象-各个方法之间也不需要用’-’隔开。" class="headerlink" title="定义类方法不需要function关键字,Point也不是对象,各个方法之间也不需要用’,’隔开。"></a>定义类方法不需要function关键字,Point也不是对象,各个方法之间也不需要用’,’隔开。</h3><pre><code>class Point &#123;
  // ...
&#125;

typeof Point // &quot;function&quot;
Point === Point.prototype.constructor // true</code></pre>
<h3 id="这代表类数据类型是函数，使用时也是对类使用-new-命令-跟构造函数的用法完全一致。"><a href="#这代表类数据类型是函数，使用时也是对类使用-new-命令-跟构造函数的用法完全一致。" class="headerlink" title="这代表类数据类型是函数，使用时也是对类使用 new 命令,跟构造函数的用法完全一致。"></a>这代表类数据类型是函数，使用时也是对类使用 new 命令,跟构造函数的用法完全一致。</h3><pre><code>const b = new Point();
b.toString() //调用</code></pre>
<h3 id="注·类的所有方法都定义在类的prototype属性上面。调用类的方法-其实就是调用原型上的方法"><a href="#注·类的所有方法都定义在类的prototype属性上面。调用类的方法-其实就是调用原型上的方法" class="headerlink" title="注·类的所有方法都定义在类的prototype属性上面。调用类的方法,其实就是调用原型上的方法."></a>注·类的所有方法都定义在类的prototype属性上面。调用类的方法,其实就是调用原型上的方法.</h3><p><font color=blue><strong>类内部定义的所有方法，都是不可枚举的(non-enumerable),这和es5不同</strong></font></p>
<pre><code>**es6**
class Point &#123;
  constructor(x, y) &#123;
    // ...
  &#125;
  toString() &#123;
    // ...
  &#125;
&#125;
Object.keys(Point.prototype)
// []
Object.getOwnPropertyNames(Point.prototype)
// [&quot;constructor&quot;,&quot;toString&quot;]</code></pre>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><pre><code>es5
var Point = function (x, y) &#123;
  // ...
&#125;;
Point.prototype.toString = function () &#123;
  // ...
&#125;;
Object.keys(Point.prototype)
// [&quot;toString&quot;]
Object.getOwnPropertyNames(Point.prototype)
// [&quot;constructor&quot;,&quot;toString&quot;]</code></pre>
<h3 id="类的实例-实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）"><a href="#类的实例-实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）" class="headerlink" title="类的实例(实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）)"></a>类的实例(实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）)</h3><pre><code>//定义类
class Point &#123;

  constructor(x, y) &#123;
    this.x = x;
    this.y = y;
  &#125;

  toString() &#123;
    return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;;
  &#125;

&#125;

var point = new Point(2, 3);

point.toString() // (2, 3)

point.hasOwnProperty(&#39;x&#39;) // true
point.hasOwnProperty(&#39;y&#39;) // true
point.hasOwnProperty(&#39;toString&#39;) // false
point.__proto__.hasOwnProperty(&#39;toString&#39;) // true</code></pre>
<h5 id="x和y都是实例point自身属性，所以hasOwnProperty-方法返回true，而toString-是原型对象的属性上，所以hasOwnProperty-方法返回false"><a href="#x和y都是实例point自身属性，所以hasOwnProperty-方法返回true，而toString-是原型对象的属性上，所以hasOwnProperty-方法返回false" class="headerlink" title="x和y都是实例point自身属性，所以hasOwnProperty()方法返回true，而toString()是原型对象的属性上，所以hasOwnProperty()方法返回false"></a>x和y都是实例point自身属性，所以hasOwnProperty()方法返回true，而toString()是原型对象的属性上，所以hasOwnProperty()方法返回false</h5><h3 id="类的所有实例共享一个原型对象"><a href="#类的所有实例共享一个原型对象" class="headerlink" title="类的所有实例共享一个原型对象"></a>类的所有实例共享一个原型对象</h3><pre><code>var p1 = new Point(2,3);
var p2 = new Point(3,2);

p1.__proto__ === p2.__proto__
//true</code></pre>
<h3 id="因为他们的原型都是Point-prototype，所以为true。"><a href="#因为他们的原型都是Point-prototype，所以为true。" class="headerlink" title="因为他们的原型都是Point.prototype，所以为true。"></a>因为他们的原型都是Point.prototype，所以为true。</h3><h3 id="这也意味着，可以通过实例的-proto-属性为“类”添加方法。我们可以使用-Object-getPrototypeOf-方法来获取实例对象的原型，然后再来为原型添加方法-属性。"><a href="#这也意味着，可以通过实例的-proto-属性为“类”添加方法。我们可以使用-Object-getPrototypeOf-方法来获取实例对象的原型，然后再来为原型添加方法-属性。" class="headerlink" title="这也意味着，可以通过实例的__proto__属性为“类”添加方法。我们可以使用 Object.getPrototypeOf 方法来获取实例对象的原型，然后再来为原型添加方法/属性。"></a>这也意味着，可以通过实例的__proto__属性为“类”添加方法。我们可以使用 Object.getPrototypeOf 方法来获取实例对象的原型，然后再来为原型添加方法/属性。</h3><pre><code>p1.__proto__.printName = function () &#123; return &#39;Oops&#39; &#125;;

p1.printName() // &quot;Oops&quot;
p2.printName() // &quot;Oops&quot;

var p3 = new Point(4,2);
p3.printName() // &quot;Oops&quot;</code></pre>
<p><strong>使用实例的__proto__属性改写原型，必须相当谨慎，不推荐使用，因为这会改变“类”的原始定义，影响到所有实例</strong></p>
<h2 id="取值函数-getter-和存值函数-setter-在类的内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为"><a href="#取值函数-getter-和存值函数-setter-在类的内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为" class="headerlink" title="取值函数(getter)和存值函数(setter) 在类的内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为"></a>取值函数(getter)和存值函数(setter) 在类的内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为</h2><h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><pre><code>class MyClass &#123;
  constructor() &#123;
    // ...
  &#125;
  get prop() &#123;
    return &#39;getter&#39;;
  &#125;
  set prop(value) &#123;
    console.log(&#39;setter: &#39;+value);
  &#125;
&#125;

let inst = new MyClass();

inst.prop = 123;// setter: 123

inst.prop // getter</code></pre>
<h3 id="prop属性有对应的存值函数和取值函数，因此赋值和读取行为都被自定义了。"><a href="#prop属性有对应的存值函数和取值函数，因此赋值和读取行为都被自定义了。" class="headerlink" title="prop属性有对应的存值函数和取值函数，因此赋值和读取行为都被自定义了。"></a>prop属性有对应的存值函数和取值函数，因此赋值和读取行为都被自定义了。</h3><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ol>
<li>严格模式<ul>
<li>类的内部，默认就是严格模式，所以不需要使用use strict指定运行模式</li>
</ul>
</li>
<li>不存在提升<ul>
<li>类不存在变量提升<pre><code>new Foo(); // ReferenceError
class Foo &#123;&#125;</code></pre>
</li>
</ul>
</li>
<li>name 属性<ul>
<li>ES6 的类只是 ES5 的构造函数的一层包装，所以函数的许多特性都被Class继承，包括name属性<pre><code>class Point&#123;&#125;
console.log(Point.name) // &#39;Point&#39;</code></pre>
name属性总是返回紧跟在class关键字后面的类名</li>
</ul>
</li>
<li>Generator 方法<ul>
<li>如果某个方法之前加上星号（*），就表示该方法是一个 Generator 函数。<br>```<br>class Foo {<br>constructor(…args) {<br>this.args = args;<br>}</li>
</ul>
</li>
</ol>
<ul>
<li><a href="">Symbol.iterator</a> {<br>for (let arg of this.args) {<br>  yield arg;<br>}<br>}<br>}</li>
</ul>
<p>for (let x of new Foo(‘hello’, ‘world’)) {<br>  console.log(x);<br>}<br>// hello<br>// world</p>
<pre><code>* Foo类的Symbol.iterator方法前有一个星号，表示该方法是一个 Generator 函数。Symbol.iterator方法返回一个Foo类的默认遍历器，for...of循环会自动调用这个遍历器。
5. this 的指向
   类的方法内部如果含有this，它默认指向类的实例

## 静态方法 
   * 类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。(如果静态方法包含this关键字，这个this指的是类,父类的静态方法，可以被子类继承)
   * 静态方法也是可以从super对象上调用的

## 实例属性新写法

​     实例属性除了定义在constructor()方法里面的this上面也可以定义在类的最顶层。



```javascript
class IncreasingCounter&#123;
  constructor()&#123;
     this._count = 0
  &#125;
  get value()&#123;
      console.log(&#39;Getting the current value!&#39;);
      return this._count;
  &#125;
    increment()&#123;
        this,_count++
    &#125;
&#125;</code></pre>
]]></content>
  </entry>
  <entry>
    <title>hook的整理使用</title>
    <url>/2020/12/27/hook/</url>
    <content><![CDATA[<h3 id="hook简介"><a href="#hook简介" class="headerlink" title="hook简介"></a>hook简介</h3><font color=#FF0000 >
     Hook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。
</font>

<h5 id="useState使用"><a href="#useState使用" class="headerlink" title="useState使用"></a>useState使用</h5><pre><code>import React, &#123; useState &#125; from &#39;react&#39;;
function Example() &#123;
  // 声明一个新的叫做 “count” 的 state 变量
  const [count, setCount] = useState(0);
  return (
    &lt;div&gt;
      &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;
      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;
        Click me
      &lt;/button&gt;
    &lt;/div&gt;
  );
&#125;</code></pre>
<h2 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h2><font color=#ff0000>
可以实现在函数组件中使用 state count是值,setCount是修改的方法
</font>

<h2 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h2><pre><code>import React, &#123; useState, useEffect &#125; from &#39;react&#39;;

function Example() &#123;
  const [count, setCount] = useState(0);

  // Similar to componentDidMount and componentDidUpdate:
  useEffect(() =&gt; &#123;
    // Update the document title using the browser API
    document.title = `You clicked $&#123;count&#125; times`;
  &#125;);

  return (
    &lt;div&gt;
      &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;
      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;
        Click me
      &lt;/button&gt;
    &lt;/div&gt;
  );
&#125;</code></pre>
<p><strong>&lt;font color==#00000 &gt;很多情况下，我们希望在组件加载和更新时执行同样的操作。从概念上说，我们希望它在每次渲染之后执行 —— 但 React 的 class 组件没有提供这样的方法。即使我们提取出一个方法，我们还是要在两个地方调用它。</font></strong></p>
<h2 id="useEffect是在加载前或更新时都会使用-替代了componentDidMount-和componentDidUpdate-集合起来"><a href="#useEffect是在加载前或更新时都会使用-替代了componentDidMount-和componentDidUpdate-集合起来" class="headerlink" title="useEffect是在加载前或更新时都会使用 替代了componentDidMount()和componentDidUpdate() 集合起来"></a>useEffect是在加载前或更新时都会使用 替代了componentDidMount()和componentDidUpdate() 集合起来</h2><p><font color=red>不要在循环，条件或嵌套函数中调用 Hook， 确保总是在你的 React 函数的最顶层调用他们。遵守这条规则，你就能确保 Hook 在每一次渲染中都按照同样的顺序被调用。这让 React 能够在多次的 useState 和 useEffect 调用之间保持 hook 状态的正确。<br><font/></p>
<h4 id="useContext-接收一个context对象并返回当前的值"><a href="#useContext-接收一个context对象并返回当前的值" class="headerlink" title="useContext 接收一个context对象并返回当前的值"></a>useContext 接收一个context对象并返回当前的值</h4><pre><code> const value = useContext(MyContext);</code></pre>
<h3 id="注意-他传入的值不是Consumer-消费者-也不是Provider生产者而是context对象本身"><a href="#注意-他传入的值不是Consumer-消费者-也不是Provider生产者而是context对象本身" class="headerlink" title="注意 : 他传入的值不是Consumer(消费者)也不是Provider生产者而是context对象本身"></a>注意 : <font color=blue>他传入的值不是Consumer(消费者)也不是Provider生产者而是context对象本身</font></h3><blockquote>
<p>useContext(MyContext) 只是让你能够读取 context 的值以及订阅 context 的变化。你仍然需要在上层组件树中使用 &lt;MyContext.Provider&gt; 来为下层组件提供 context</p>
</blockquote>
<h2 id="额外的Hook"><a href="#额外的Hook" class="headerlink" title="额外的Hook"></a>额外的Hook</h2><ol>
<li>useReducer<pre><code>const [state, dispatch] = useReducer(reducer, initialArg, init);</code></pre>
<h3 id="它拥有三个值，第一个值是reducer函数-他会返回新的值来覆盖原来的值-第二个值是初始化的参数，第三个值是惰性初始化-需要将-init-函数作为-useReducer-的第三个参数传入，这样初始-state-将被设置为-init-initialArg"><a href="#它拥有三个值，第一个值是reducer函数-他会返回新的值来覆盖原来的值-第二个值是初始化的参数，第三个值是惰性初始化-需要将-init-函数作为-useReducer-的第三个参数传入，这样初始-state-将被设置为-init-initialArg" class="headerlink" title="它拥有三个值，第一个值是reducer函数,他会返回新的值来覆盖原来的值,第二个值是初始化的参数，第三个值是惰性初始化,需要将 init 函数作为 useReducer 的第三个参数传入，这样初始 state 将被设置为 init(initialArg)"></a>它拥有三个值，第一个值是reducer函数,他会返回新的值来覆盖原来的值,第二个值是初始化的参数，第三个值是惰性初始化,需要将 init 函数作为 useReducer 的第三个参数传入，这样初始 state 将被设置为 init(initialArg)</h3></li>
</ol>
<h2 id="注意-传入函数不要在生成dom的函数中-否则首次调用会执行两回"><a href="#注意-传入函数不要在生成dom的函数中-否则首次调用会执行两回" class="headerlink" title="注意 传入函数不要在生成dom的函数中,否则首次调用会执行两回"></a>注意 传入函数不要在生成dom的函数中,否则首次调用会执行两回</h2><pre><code>function init(initialCount) &#123;
    return &#123; count: initialCount &#125;;
&#125;
function reducer(state, action) &#123;
    switch (action.type) &#123;
        case &#39;increment&#39;:
          return &#123; count: state.count + 1 &#125;;
        case &#39;decrement&#39;:
          return &#123; count: state.count - 1 &#125;;
        case &#39;reset&#39;:
          return init(action.payload);
        default:
          throw new Error();
    &#125;
&#125;
function Counter(&#123; initialCount &#125;) &#123;
    const [state, dispatch] = useReducer(reducer, initialCount, init);
    return (
        &lt;div&gt;
          Count: &#123;state.count&#125;
          &lt;button
            onClick=&#123;() =&gt; dispatch(&#123; type: &#39;reset&#39;, payload: initialCount &#125;)&#125;&gt;
            Reset
          &lt;/button&gt;
          &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: &#39;decrement&#39; &#125;)&#125;&gt;-&lt;/button&gt;
          &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: &#39;increment&#39; &#125;)&#125;&gt;+&lt;/button&gt;
        &lt;div /&gt;
    );
&#125;</code></pre>
<h3 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h3><pre><code>const [count, setCount] = useState(1);
    const [val, setVal] = useState(&#39;&#39;);
    const [count, setCount] = useState(1);
    const callback = useCallback(() =&gt; &#123;
        console.log(count);
    &#125;, [count]);
    return &lt;div&gt;
        &lt;h4&gt;&#123;count&#125;&lt;/h4&gt;
        &lt;h4&gt;&#123;set.size&#125;&lt;/h4&gt;
        &lt;div&gt;
            &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;+&lt;/button&gt;
            &lt;input value=&#123;val&#125; onChange=&#123;event =&gt; setVal(event.target.value)&#125;/&gt;
        &lt;/div&gt;
    &lt;/div&gt;;
</code></pre>
<ul>
<li>在所依赖的count变化时会返回新的函数,count没有变化时不变<h4 id="会在组件第一次渲染的时候执行，之后会在其依赖的变量发生改变时再次执行，并且返回缓存的函数"><a href="#会在组件第一次渲染的时候执行，之后会在其依赖的变量发生改变时再次执行，并且返回缓存的函数" class="headerlink" title="会在组件第一次渲染的时候执行，之后会在其依赖的变量发生改变时再次执行，并且返回缓存的函数"></a>会在组件第一次渲染的时候执行，之后会在其依赖的变量发生改变时再次执行，并且返回缓存的函数</h4><h3 id="其可以应用在父组件向子组件传参-当父组件里面的值变化时，使子组件避免不必要的更新"><a href="#其可以应用在父组件向子组件传参-当父组件里面的值变化时，使子组件避免不必要的更新" class="headerlink" title="其可以应用在父组件向子组件传参,当父组件里面的值变化时，使子组件避免不必要的更新"></a>其可以应用在父组件向子组件传参,当父组件里面的值变化时，使子组件避免不必要的更新</h3></li>
</ul>
<h2 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h2><pre><code>export default function WithMemo() &#123;
    const [count, setCount] = useState(1);
    const [val, setValue] = useState(&#39;&#39;);
    const expensive = useMemo(() =&gt; &#123;
        console.log(&#39;compute&#39;);
        let sum = 0;
        for (let i = 0; i &lt; count * 100; i++) &#123;
            sum += i;
        &#125;
        return sum;
    &#125;, [count]);

    return &lt;div&gt;
        &lt;h4&gt;&#123;count&#125;-&#123;expensive&#125;&lt;/h4&gt;
        &#123;val&#125;
        &lt;div&gt;
            &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;+c1&lt;/button&gt;
            &lt;input value=&#123;val&#125; onChange=&#123;event =&gt; setValue(event.target.value)&#125;/&gt;
        &lt;/div&gt;
    &lt;/div&gt;;</code></pre>
<ul>
<li> 同上,会在组件第一次渲染的时候执行，之后会在其依赖的变量发生改变时再次执行，并且返回缓存的变量<h3 id="使用useMemo来执行昂贵的计算，然后将计算值返回，并且将count作为依赖值传递进去。这样，就只会在count改变的时候触发expensive执行，在修改val的时候，返回上一次缓存的值。"><a href="#使用useMemo来执行昂贵的计算，然后将计算值返回，并且将count作为依赖值传递进去。这样，就只会在count改变的时候触发expensive执行，在修改val的时候，返回上一次缓存的值。" class="headerlink" title="使用useMemo来执行昂贵的计算，然后将计算值返回，并且将count作为依赖值传递进去。这样，就只会在count改变的时候触发expensive执行，在修改val的时候，返回上一次缓存的值。"></a>使用useMemo来执行昂贵的计算，然后将计算值返回，并且将count作为依赖值传递进去。这样，就只会在count改变的时候触发expensive执行，在修改val的时候，返回上一次缓存的值。</h3></li>
</ul>
<h3 id="useRef-返回一个可变的-ref-对象，其-current-属性被初始化为传入的参数。返回的-ref-对象在组件的整个生命周期内保持不变。"><a href="#useRef-返回一个可变的-ref-对象，其-current-属性被初始化为传入的参数。返回的-ref-对象在组件的整个生命周期内保持不变。" class="headerlink" title="useRef  返回一个可变的 ref 对象，其 .current 属性被初始化为传入的参数。返回的 ref 对象在组件的整个生命周期内保持不变。"></a>useRef  返回一个可变的 ref 对象，其 .current 属性被初始化为传入的参数。返回的 ref 对象在组件的整个生命周期内保持不变。</h3><pre><code>const refContainer = useRef(null);</code></pre>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><pre><code>function TextInputWithFocusButton() &#123;
  const inputEl = useRef(null);
  const onButtonClick = () =&gt; &#123;
    // `current` 指向已挂载到 DOM 上的文本输入元素
    inputEl.current.focus();
  &#125;;
  return (
    &lt;div&gt;
      &lt;input ref=&#123;inputEl&#125; type=&quot;text&quot;/&gt;
      &lt;button onClick=&#123;onButtonClick&#125;&gt;Focus the input&lt;/button&gt;
    &lt;/div&gt;
  );
&#125;</code></pre>
<h3 id="还有很多hook方法-例如"><a href="#还有很多hook方法-例如" class="headerlink" title="还有很多hook方法 例如"></a>还有很多hook方法 例如</h3><ol>
<li>useImperativeHandle</li>
<li>useLayoutEffect</li>
<li>useDebugValue</li>
</ol>
<p>下次再见</p>
]]></content>
  </entry>
  <entry>
    <title>JavaScript的严格模式</title>
    <url>/2020/12/30/%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h4 id="声明严格模式"><a href="#声明严格模式" class="headerlink" title="声明严格模式"></a>声明严格模式</h4><p>通过在脚本或函数的头部添加use strict,表达式来声明。</p>
<pre><code class="js">&#39;use strict&#39;
x = 3.14;   // 报错(x 未定义)</code></pre>
<p>注:在函数内部声明的变量是局部作用域(只在函数内使用严格模式)</p>
<pre><code class="js">function myFunction()&#123;
    &#39;use strict&#39;
    y = 3.15 //报错(未定义)
&#125;</code></pre>
<h4 id="严格模式限制"><a href="#严格模式限制" class="headerlink" title="严格模式限制"></a>严格模式限制</h4><h5 id="1-不允许使用未声明的变量："><a href="#1-不允许使用未声明的变量：" class="headerlink" title="1.不允许使用未声明的变量："></a>1.不允许使用未声明的变量：</h5><pre><code class="js">&#39;use strict&#39;;
x = 3.14 : // 报错未定义</code></pre>
<h5 id="2-不允许删除变量、对象和函数。"><a href="#2-不允许删除变量、对象和函数。" class="headerlink" title="2.不允许删除变量、对象和函数。"></a>2.不允许删除变量、对象和函数。</h5><pre><code class="js">&#39;use strict&#39;;

var x = 3.15

delect x, // 错误

function x(p1, p2) &#123;&#125;;

delete x;                // 报错</code></pre>
<h5 id="3-不允许变量重名"><a href="#3-不允许变量重名" class="headerlink" title="3.不允许变量重名"></a>3.不允许变量重名</h5><pre><code class="js">&#39;use strict&#39;
function x(p1,p1)&#123;&#125;; // 报错</code></pre>
<h5 id="4-不允许使用8进制"><a href="#4-不允许使用8进制" class="headerlink" title="4.不允许使用8进制"></a>4.不允许使用8进制</h5><pre><code class="js">&#39;use strict&#39;
var x = 010; // 报错</code></pre>
<h5 id="5-不允许使用转义字符"><a href="#5-不允许使用转义字符" class="headerlink" title="5.不允许使用转义字符"></a>5.不允许使用转义字符</h5><pre><code class="js">&#39;use strict&#39;
var x = \010; //报错</code></pre>
<h5 id="6-不允许对只读属性赋值；"><a href="#6-不允许对只读属性赋值；" class="headerlink" title="6.不允许对只读属性赋值；"></a>6.不允许对只读属性赋值；</h5><pre><code class="js">&#39;use strict&#39;;
var obj = &#123;&#125;;
Object.defineProperty(obj,&#39;x&#39;,&#123;value:0,writable:false&#125;)
obj.x = 3.14 //报错</code></pre>
<h5 id="7-不允许删除一个不允许删除的属性"><a href="#7-不允许删除一个不允许删除的属性" class="headerlink" title="7.不允许删除一个不允许删除的属性"></a>7.不允许删除一个不允许删除的属性</h5><pre><code class="js">&#39;use strict&#39;
delete Object.proptotype //报错</code></pre>
<h5 id="8-变量名不能使用-“eval”-和-“arguments”字符串；"><a href="#8-变量名不能使用-“eval”-和-“arguments”字符串；" class="headerlink" title="8.变量名不能使用  “eval”  和 “arguments”字符串；"></a>8.变量名不能使用  “eval”  和 “arguments”字符串；</h5><pre><code class="js">&#39;use strict&#39;
var eval = 3.15; //报错
var arguments = 3.15 //报错</code></pre>
<h5 id="9-处于安全原因-作用域eval-创建的变量不能被调用"><a href="#9-处于安全原因-作用域eval-创建的变量不能被调用" class="headerlink" title="9.处于安全原因,作用域eval()创建的变量不能被调用"></a>9.处于安全原因,作用域eval()创建的变量不能被调用</h5><pre><code class="js">&#39;use strict&#39;
eval (&#39;var x = 3&#39;);
conaole.log(x) // 报错</code></pre>
<h5 id="10-禁止this关键字指向全局对象。"><a href="#10-禁止this关键字指向全局对象。" class="headerlink" title="10.禁止this关键字指向全局对象。"></a>10.禁止this关键字指向全局对象。</h5><pre><code class="js">//非严格模式
function f()&#123;
    return !this;
&#125; 
// 返回false,默认指向全局对象，！this就是false

&#39;use strict&#39;
function f()&#123;
    return this
&#125;
// 严格模式下，this的值默认为undefined ,!this就是true</code></pre>
<h5 id="11-严格模式保留字"><a href="#11-严格模式保留字" class="headerlink" title="11.严格模式保留字"></a>11.严格模式保留字</h5><ul>
<li>implements</li>
<li>interface</li>
<li>let</li>
<li>package</li>
<li>private</li>
<li>protected</li>
<li>public</li>
<li>static</li>
<li>yield</li>
</ul>
<pre><code class="js">&quot;use strict&quot;;
var public = 1500;      // 报错</code></pre>
]]></content>
  </entry>
  <entry>
    <title>vue面试题整理</title>
    <url>/2021/01/28/vue%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h4 id="1-history模式，页面返回404，如何解决"><a href="#1-history模式，页面返回404，如何解决" class="headerlink" title="1. history模式，页面返回404，如何解决?"></a>1. history模式，页面返回404，如何解决?</h4><p>history是html5新增的api，他的功能是修改地址栏但是不像服务器端发送真是请求，如果页面返回404，说明发送了请求到服务器端,并且服务器端对该请求没有做处理，那么解决404的方案就是服务器端对于这类请求重定向到某个页面即可</p>
<h4 id="2-聊一聊commonjs规范"><a href="#2-聊一聊commonjs规范" class="headerlink" title="2.聊一聊commonjs规范"></a>2.聊一聊commonjs规范</h4><h5 id="概述-：-node应用由模块组成，采用的commonjs模块规范。每一个文件就是一个模块，拥有自己独立的作用域，变量，以及方法等，对其他的模块都不可见。CommonJS规范规定，每个模块内部，module变量代表当前模块。这个变量是一个对象，它的exports属性（即module-exports）是对外的接口。加载某个模块，其实是加载该模块的module-exports属性。require方法用于加载模块。"><a href="#概述-：-node应用由模块组成，采用的commonjs模块规范。每一个文件就是一个模块，拥有自己独立的作用域，变量，以及方法等，对其他的模块都不可见。CommonJS规范规定，每个模块内部，module变量代表当前模块。这个变量是一个对象，它的exports属性（即module-exports）是对外的接口。加载某个模块，其实是加载该模块的module-exports属性。require方法用于加载模块。" class="headerlink" title="概述 ： node应用由模块组成，采用的commonjs模块规范。每一个文件就是一个模块，拥有自己独立的作用域，变量，以及方法等，对其他的模块都不可见。CommonJS规范规定，每个模块内部，module变量代表当前模块。这个变量是一个对象，它的exports属性（即module.exports）是对外的接口。加载某个模块，其实是加载该模块的module.exports属性。require方法用于加载模块。"></a>概述 ： node应用由模块组成，采用的commonjs模块规范。每一个文件就是一个模块，拥有自己独立的作用域，变量，以及方法等，对其他的模块都不可见。CommonJS规范规定，每个模块内部，module变量代表当前模块。这个变量是一个对象，它的exports属性（即module.exports）是对外的接口。加载某个模块，其实是加载该模块的module.exports属性。require方法用于加载模块。</h5><h5 id="CommonJS模块的特点如下"><a href="#CommonJS模块的特点如下" class="headerlink" title="CommonJS模块的特点如下 :"></a>CommonJS模块的特点如下 :</h5><h5 id="1-所有代码都运行在模块作用域，不会污染全局作用域。"><a href="#1-所有代码都运行在模块作用域，不会污染全局作用域。" class="headerlink" title="(1)  所有代码都运行在模块作用域，不会污染全局作用域。"></a>(1)  所有代码都运行在模块作用域，不会污染全局作用域。</h5><h5 id="2-模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。"><a href="#2-模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。" class="headerlink" title="(2) 模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。"></a>(2) 模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。</h5><h5 id="3-模块加载的顺序，按照其在代码中出现的顺序。"><a href="#3-模块加载的顺序，按照其在代码中出现的顺序。" class="headerlink" title="(3) 模块加载的顺序，按照其在代码中出现的顺序。"></a>(3) 模块加载的顺序，按照其在代码中出现的顺序。</h5><h5 id="模块加载机制-："><a href="#模块加载机制-：" class="headerlink" title="模块加载机制 ："></a>模块加载机制 ：</h5><h5 id="commonsJS的加载机制，输入的是被输出值的拷贝。也就是说，一旦输出一个值，模块内部的变化就影响不到这个值了。"><a href="#commonsJS的加载机制，输入的是被输出值的拷贝。也就是说，一旦输出一个值，模块内部的变化就影响不到这个值了。" class="headerlink" title="commonsJS的加载机制，输入的是被输出值的拷贝。也就是说，一旦输出一个值，模块内部的变化就影响不到这个值了。"></a>commonsJS的加载机制，输入的是被输出值的拷贝。也就是说，一旦输出一个值，模块内部的变化就影响不到这个值了。</h5><h5 id="require命令-："><a href="#require命令-：" class="headerlink" title="require命令 ："></a>require命令 ：</h5><h5 id="1-require命令用于加载模块文件，相当于读入并执行一个js文件，然后返回该模块的exports对象，没有发现指定模块，则就会报错"><a href="#1-require命令用于加载模块文件，相当于读入并执行一个js文件，然后返回该模块的exports对象，没有发现指定模块，则就会报错" class="headerlink" title="(1) require命令用于加载模块文件，相当于读入并执行一个js文件，然后返回该模块的exports对象，没有发现指定模块，则就会报错"></a>(1) require命令用于加载模块文件，相当于读入并执行一个js文件，然后返回该模块的exports对象，没有发现指定模块，则就会报错</h5><h5 id="2-加载规则"><a href="#2-加载规则" class="headerlink" title="(2) 加载规则 :"></a>(2) 加载规则 :</h5><p>​     a:如果参数字符串以“/”开头，则表示加载的是一个位于绝对路径的模块文件。比如，require(‘/home/marco/foo.js’)将加载/home/marco/foo.js。</p>
<p>​     b.如果参数字符串以“./”开头，则表示加载的是一个位于相对路径（跟当前执行脚本的位置相比）的模块文件。比如，require(‘./circle’)将加载当前脚本同一目录的circle.js。</p>
<p>​     c.如果参数字符串不以“./“或”/“开头，则表示加载的是一个默认提供的核心模块（位于Node的系统安装目录中），或者一个位于各级node_modules目录的已安装模块（全局安装或局部安装）。</p>
<h5 id="模块的缓存：第一次加载该模块，node会缓存该模块。再次加载，直接从缓存中取出该模块的module-exports属性。缓存保存在require-cache中，可操作该属性进行删除。"><a href="#模块的缓存：第一次加载该模块，node会缓存该模块。再次加载，直接从缓存中取出该模块的module-exports属性。缓存保存在require-cache中，可操作该属性进行删除。" class="headerlink" title="模块的缓存：第一次加载该模块，node会缓存该模块。再次加载，直接从缓存中取出该模块的module.exports属性。缓存保存在require.cache中，可操作该属性进行删除。"></a>模块的缓存：第一次加载该模块，node会缓存该模块。再次加载，直接从缓存中取出该模块的module.exports属性。缓存保存在require.cache中，可操作该属性进行删除。</h5><h4 id="3-vue的指令有哪些？作用是什么？"><a href="#3-vue的指令有哪些？作用是什么？" class="headerlink" title="3.vue的指令有哪些？作用是什么？"></a>3.vue的指令有哪些？作用是什么？</h4><pre><code>&#123;&#123;&#125;&#125; : 插值

v-if,v-else-if,v-else : 条件成立渲染

v-show : 根据条件动态切换display的值

v-bind : 动态绑定属性值

v-on : 监听属性

v-modul ：在表单控件或组件上进行双向绑定

v-html : 插入字符串并解析html

v-text：同&#123;&#123;&#125;&#125;  插到标签上</code></pre>
<h4 id="4-eventBus是什么？"><a href="#4-eventBus是什么？" class="headerlink" title="4.eventBus是什么？"></a>4.eventBus是什么？</h4><p>​       是vue跨组件传参的方法，首先在根组件中输入 Vue.prototype.$bus=new Vue()  然后 在要传参的组件中通过this.$bus.$emit传递自定义事件和参数 然后在接收参数的组件中通过this.$bus.$on接收自定义事件名和参数</p>
<h4 id="5-vue-router的原理（history、hash）"><a href="#5-vue-router的原理（history、hash）" class="headerlink" title="5.vue-router的原理（history、hash）"></a>5.vue-router的原理（history、hash）</h4><p>特点是更新视图但不重新请求页面，是前端路由原理的核心之一，目前在浏览器环境中这一功能的实现主要有2种方式,Hash模式和History模式</p>
<p>（1）利用URL中的hash(“#”);</p>
<p>（2）利用History,在HTML5中新增的方法;</p>
<p>1、Hash模式：<br>   hash（#）是URL 的锚点，代表的是网页中的一个位置，单单改变#后的部分，浏览器只会滚动到相应位置，不会重新加载网页，也就是说 #是用来指导浏览器动作的，对服务器端完全无用，HTTP请求中也不会不包括#；同时每一次改变#后的部分，都会在浏览器的访问历史中增加一个记录，使用”后退”按钮，就可以回到上一个位置；</p>
<p>2、History模式： </p>
<p>  HTML5 History API提供了一种功能，能让开发人员在不刷新整个页面的情况下修改站点的URL，就是利用 history.pushState API 来完成 URL 跳转而无须重新加载页面；</p>
<p>通常情况下，我们会选择使用History模式，原因就是Hash模式下URL带着‘#’会显得不美观；</p>
]]></content>
  </entry>
  <entry>
    <title>同源及跨域</title>
    <url>/2021/01/11/%E5%90%8C%E6%BA%90%E5%8F%8A%E8%B7%A8%E5%9F%9F/</url>
    <content><![CDATA[<h3 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h3><ul>
<li>ajax 请求时，浏览器要求当前网页和server必须同源（安全）</li>
<li>同源：协议，域名，端口，三者必须一致</li>
</ul>
<blockquote>
<p><strong>同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。</strong></p>
</blockquote>
<h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><p>跨域，指的是从一个域名去请求另外一个域名的资源。即跨域名请求！跨域时，浏览器不能执行其他域名网站的脚本，是由浏览器的同源策略造成的，是浏览器施加的安全限制。</p>
<p>跨域的严格一点来说就是只要协议，域名，端口有任何一个的不同，就被当作是跨域。</p>
<h3 id="解决同源"><a href="#解决同源" class="headerlink" title="解决同源"></a>解决同源</h3><h5 id="加载图片-引用CSS-和-JS文件时-可无视同源策略"><a href="#加载图片-引用CSS-和-JS文件时-可无视同源策略" class="headerlink" title="加载图片 引用CSS 和 JS文件时 可无视同源策略"></a>加载图片 引用CSS 和 JS文件时 可无视同源策略</h5><ul>
<li><code>&lt;img src=&quot;跨域的图片地址&quot; /&gt;</code>  <strong>可用于统计打点，可使用第三方统计服务</strong></li>
<li><code>&lt;link href=&quot;跨域的css地址&quot; /&gt;</code> <strong>可使用CDN,CDN一般都是外域</strong></li>
<li><code>&lt;script src=&quot;跨域的js地址&quot;&gt;&lt;/script&gt;</code> <strong>可实现JSONP</strong></li>
</ul>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="1-JSONP"><a href="#1-JSONP" class="headerlink" title="1.  JSONP"></a>1.  JSONP</h4><h4 id="2-jquery-自带jsonp"><a href="#2-jquery-自带jsonp" class="headerlink" title="2. jquery 自带jsonp"></a>2. jquery 自带jsonp</h4>]]></content>
  </entry>
  <entry>
    <title>proxy</title>
    <url>/2021/01/25/proxy/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。</p>
<p>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</p>
<pre><code class="javascript">var obj = new Proxy(&#123;&#125;, &#123;
  get: function (target, propKey, receiver) &#123;
    console.log(`getting $&#123;propKey&#125;!`);
    return Reflect.get(target, propKey, receiver);
  &#125;,
  set: function (target, propKey, value, receiver) &#123;
    console.log(`setting $&#123;propKey&#125;!`);
    return Reflect.set(target, propKey, value, receiver);
  &#125;
&#125;);</code></pre>
<p>上面代码对一个空对象架设了一层拦截，重定义了属性的读取（<code>get</code>）和设置（<code>set</code>）行为。这里暂时先不解释具体的语法，只看运行结果。对设置了拦截行为的对象<code>obj</code>，去读写它的属性，就会得到下面的结果。</p>
<pre><code class="javascript">obj.count = 1
//  setting count!
++obj.count
//  getting count!
//  setting count!
//  2</code></pre>
<p>上面代码说明，Proxy 实际上重载（overload）了点运算符，即用自己的定义覆盖了语言的原始定义。</p>
<p>ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例。</p>
<pre><code class="javascript">var proxy = new Proxy(target, handler);</code></pre>
<p>Proxy 对象的所有用法，都是上面这种形式，不同的只是<code>handler</code>参数的写法。其中，<code>new Proxy()</code>表示生成一个<code>Proxy</code>实例，<code>target</code>参数表示所要拦截的目标对象，<code>handler</code>参数也是一个对象，用来定制拦截行为。</p>
<p>下面是另一个拦截读取属性行为的例子。</p>
<pre><code class="javascript">var proxy = new Proxy(&#123;&#125;, &#123;
  get: function(target, propKey) &#123;
    return 35;
  &#125;
&#125;);

proxy.time // 35
proxy.name // 35
proxy.title // 35</code></pre>
<p>上面代码中，作为构造函数，<code>Proxy</code>接受两个参数。第一个参数是所要代理的目标对象（上例是一个空对象），即如果没有<code>Proxy</code>的介入，操作原来要访问的就是这个对象；第二个参数是一个配置对象，对于每一个被代理的操作，需要提供一个对应的处理函数，该函数将拦截对应的操作。比如，上面代码中，配置对象有一个<code>get</code>方法，用来拦截对目标对象属性的访问请求。<code>get</code>方法的两个参数分别是目标对象和所要访问的属性。可以看到，由于拦截函数总是返回<code>35</code>，所以访问任何属性都得到<code>35</code>。</p>
<p>注意，要使得<code>Proxy</code>起作用，必须针对<code>Proxy</code>实例（上例是<code>proxy</code>对象）进行操作，而不是针对目标对象（上例是空对象）进行操作。</p>
<p>如果<code>handler</code>没有设置任何拦截，那就等同于直接通向原对象。</p>
<pre><code class="javascript">var target = &#123;&#125;;
var handler = &#123;&#125;;
var proxy = new Proxy(target, handler);
proxy.a = &#39;b&#39;;
target.a // &quot;b&quot;</code></pre>
<p>上面代码中，<code>handler</code>是一个空对象，没有任何拦截效果，访问<code>proxy</code>就等同于访问<code>target</code>。</p>
<p>一个技巧是将 Proxy 对象，设置到<code>object.proxy</code>属性，从而可以在<code>object</code>对象上调用。</p>
<pre><code class="javascript">var object = &#123; proxy: new Proxy(target, handler) &#125;;</code></pre>
<p>Proxy 实例也可以作为其他对象的原型对象。</p>
<pre><code class="javascript">var proxy = new Proxy(&#123;&#125;, &#123;
  get: function(target, propKey) &#123;
    return 35;
  &#125;
&#125;);

let obj = Object.create(proxy);
obj.time // 35</code></pre>
<p>上面代码中，<code>proxy</code>对象是<code>obj</code>对象的原型，<code>obj</code>对象本身并没有<code>time</code>属性，所以根据原型链，会在<code>proxy</code>对象上读取该属性，导致被拦截。</p>
<p>同一个拦截器函数，可以设置拦截多个操作。</p>
<pre><code class="javascript">var handler = &#123;
  get: function(target, name) &#123;
    if (name === &#39;prototype&#39;) &#123;
      return Object.prototype;
    &#125;
    return &#39;Hello, &#39; + name;
  &#125;,

  apply: function(target, thisBinding, args) &#123;
    return args[0];
  &#125;,

  construct: function(target, args) &#123;
    return &#123;value: args[1]&#125;;
  &#125;
&#125;;

var fproxy = new Proxy(function(x, y) &#123;
  return x + y;
&#125;, handler);

fproxy(1, 2) // 1
new fproxy(1, 2) // &#123;value: 2&#125;
fproxy.prototype === Object.prototype // true
fproxy.foo === &quot;Hello, foo&quot; // true</code></pre>
<p>对于可以设置、但没有设置拦截的操作，则直接落在目标对象上，按照原先的方式产生结果。</p>
<p>下面是 Proxy 支持的拦截操作一览，一共 13 种。</p>
<ul>
<li>get(target, propKey, receiver)：拦截对象属性的读取，比如proxy.foo和proxy[‘foo’]。</li>
<li>set(target, propKey, value, receiver)：拦截对象属性的设置，比如proxy.foo = v或proxy[‘foo’] = v，返回一个布尔值。</li>
<li>has(target, propKey)：拦截propKey in proxy的操作，返回一个布尔值。</li>
<li>deleteProperty(target, propKey)：拦截delete proxy[propKey]的操作，返回一个布尔值。</li>
<li>ownKeys(target)：拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for…in循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历属性。</li>
<li>getOwnPropertyDescriptor(target, propKey)：拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。</li>
<li>defineProperty(target, propKey, propDesc)：拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。</li>
<li>preventExtensions(target)：拦截Object.preventExtensions(proxy)，返回一个布尔值。</li>
<li>getPrototypeOf(target)：拦截Object.getPrototypeOf(proxy)，返回一个对象。</li>
<li>isExtensible(target)：拦截Object.isExtensible(proxy)，返回一个布尔值。</li>
<li>setPrototypeOf(target, proto)：拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。</li>
<li>apply(target, object, args)：拦截 Proxy 实例作为函数调用的操作，比如proxy(…args)、proxy.call(object, …args)、proxy.apply(…)。</li>
<li>construct(target, args)：拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(…args)。</li>
</ul>
<h2 id="Proxy-实例的方法"><a href="#Proxy-实例的方法" class="headerlink" title="Proxy 实例的方法"></a>Proxy 实例的方法</h2><p>下面是上面这些拦截方法的详细介绍。</p>
<h3 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h3><p><code>get</code>方法用于拦截某个属性的读取操作，可以接受三个参数，依次为目标对象、属性名和 proxy 实例本身（严格地说，是操作行为所针对的对象），其中最后一个参数可选。</p>
<p><code>get</code>方法的用法，上文已经有一个例子，下面是另一个拦截读取操作的例子。</p>
<pre><code class="javascript">var person = &#123;
  name: &quot;张三&quot;
&#125;;

var proxy = new Proxy(person, &#123;
  get: function(target, propKey) &#123;
    if (propKey in target) &#123;
      return target[propKey];
    &#125; else &#123;
      throw new ReferenceError(&quot;Prop name \&quot;&quot; + propKey + &quot;\&quot; does not exist.&quot;);
    &#125;
  &#125;
&#125;);

proxy.name // &quot;张三&quot;
proxy.age // 抛出一个错误</code></pre>
<p>上面代码表示，如果访问目标对象不存在的属性，会抛出一个错误。如果没有这个拦截函数，访问不存在的属性，只会返回<code>undefined</code>。</p>
<p><code>get</code>方法可以继承。</p>
<pre><code class="javascript">let proto = new Proxy(&#123;&#125;, &#123;
  get(target, propertyKey, receiver) &#123;
    console.log(&#39;GET &#39; + propertyKey);
    return target[propertyKey];
  &#125;
&#125;);

let obj = Object.create(proto);
obj.foo // &quot;GET foo&quot;</code></pre>
<p>上面代码中，拦截操作定义在<code>Prototype</code>对象上面，所以如果读取<code>obj</code>对象继承的属性时，拦截会生效。</p>
<p>下面的例子使用<code>get</code>拦截，实现数组读取负数的索引。</p>
<pre><code class="javascript">function createArray(...elements) &#123;
  let handler = &#123;
    get(target, propKey, receiver) &#123;
      let index = Number(propKey);
      if (index &lt; 0) &#123;
        propKey = String(target.length + index);
      &#125;
      return Reflect.get(target, propKey, receiver);
    &#125;
  &#125;;

  let target = [];
  target.push(...elements);
  return new Proxy(target, handler);
&#125;

let arr = createArray(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;);
arr[-1] // c</code></pre>
<p>上面代码中，数组的位置参数是<code>-1</code>，就会输出数组的倒数第一个成员。</p>
<p>利用 Proxy，可以将读取属性的操作（<code>get</code>），转变为执行某个函数，从而实现属性的链式操作。</p>
<pre><code class="javascript">var pipe = function (value) &#123;
  var funcStack = [];
  var oproxy = new Proxy(&#123;&#125; , &#123;
    get : function (pipeObject, fnName) &#123;
      if (fnName === &#39;get&#39;) &#123;
        return funcStack.reduce(function (val, fn) &#123;
          return fn(val);
        &#125;,value);
      &#125;
      funcStack.push(window[fnName]);
      return oproxy;
    &#125;
  &#125;);

  return oproxy;
&#125;

var double = n =&gt; n * 2;
var pow    = n =&gt; n * n;
var reverseInt = n =&gt; n.toString().split(&quot;&quot;).reverse().join(&quot;&quot;) | 0;

pipe(3).double.pow.reverseInt.get; // 63</code></pre>
<p>上面代码设置 Proxy 以后，达到了将函数名链式使用的效果。</p>
<p>下面的例子则是利用<code>get</code>拦截，实现一个生成各种 DOM 节点的通用函数<code>dom</code>。</p>
<pre><code class="javascript">const dom = new Proxy(&#123;&#125;, &#123;
  get(target, property) &#123;
    return function(attrs = &#123;&#125;, ...children) &#123;
      const el = document.createElement(property);
      for (let prop of Object.keys(attrs)) &#123;
        el.setAttribute(prop, attrs[prop]);
      &#125;
      for (let child of children) &#123;
        if (typeof child === &#39;string&#39;) &#123;
          child = document.createTextNode(child);
        &#125;
        el.appendChild(child);
      &#125;
      return el;
    &#125;
  &#125;
&#125;);

const el = dom.div(&#123;&#125;,
  &#39;Hello, my name is &#39;,
  dom.a(&#123;href: &#39;//example.com&#39;&#125;, &#39;Mark&#39;),
  &#39;. I like:&#39;,
  dom.ul(&#123;&#125;,
    dom.li(&#123;&#125;, &#39;The web&#39;),
    dom.li(&#123;&#125;, &#39;Food&#39;),
    dom.li(&#123;&#125;, &#39;…actually that\&#39;s it&#39;)
  )
);

document.body.appendChild(el);</code></pre>
<p>下面是一个<code>get</code>方法的第三个参数的例子，它总是指向原始的读操作所在的那个对象，一般情况下就是 Proxy 实例。</p>
<pre><code class="javascript">const proxy = new Proxy(&#123;&#125;, &#123;
  get: function(target, key, receiver) &#123;
    return receiver;
  &#125;
&#125;);
proxy.getReceiver === proxy // true</code></pre>
<p>上面代码中，<code>proxy</code>对象的<code>getReceiver</code>属性是由<code>proxy</code>对象提供的，所以<code>receiver</code>指向<code>proxy</code>对象。</p>
<pre><code class="javascript">const proxy = new Proxy(&#123;&#125;, &#123;
  get: function(target, key, receiver) &#123;
    return receiver;
  &#125;
&#125;);

const d = Object.create(proxy);
d.a === d // true</code></pre>
<p>上面代码中，<code>d</code>对象本身没有<code>a</code>属性，所以读取<code>d.a</code>的时候，会去<code>d</code>的原型<code>proxy</code>对象找。这时，<code>receiver</code>就指向<code>d</code>，代表原始的读操作所在的那个对象。</p>
<p>如果一个属性不可配置（configurable）且不可写（writable），则 Proxy 不能修改该属性，否则通过 Proxy 对象访问该属性会报错。</p>
<pre><code class="javascript">const target = Object.defineProperties(&#123;&#125;, &#123;
  foo: &#123;
    value: 123,
    writable: false,
    configurable: false
  &#125;,
&#125;);

const handler = &#123;
  get(target, propKey) &#123;
    return &#39;abc&#39;;
  &#125;
&#125;;

const proxy = new Proxy(target, handler);

proxy.foo
// TypeError: Invariant check failed</code></pre>
<h3 id="set"><a href="#set" class="headerlink" title="set()"></a>set()</h3><p><code>set</code>方法用来拦截某个属性的赋值操作，可以接受四个参数，依次为目标对象、属性名、属性值和 Proxy 实例本身，其中最后一个参数可选。</p>
<p>假定<code>Person</code>对象有一个<code>age</code>属性，该属性应该是一个不大于 200 的整数，那么可以使用<code>Proxy</code>保证<code>age</code>的属性值符合要求。</p>
<pre><code class="javascript">let validator = &#123;
  set: function(obj, prop, value) &#123;
    if (prop === &#39;age&#39;) &#123;
      if (!Number.isInteger(value)) &#123;
        throw new TypeError(&#39;The age is not an integer&#39;);
      &#125;
      if (value &gt; 200) &#123;
        throw new RangeError(&#39;The age seems invalid&#39;);
      &#125;
    &#125;

    // 对于满足条件的 age 属性以及其他属性，直接保存
    obj[prop] = value;
  &#125;
&#125;;

let person = new Proxy(&#123;&#125;, validator);

person.age = 100;

person.age // 100
person.age = &#39;young&#39; // 报错
person.age = 300 // 报错</code></pre>
<p>上面代码中，由于设置了存值函数<code>set</code>，任何不符合要求的<code>age</code>属性赋值，都会抛出一个错误，这是数据验证的一种实现方法。利用<code>set</code>方法，还可以数据绑定，即每当对象发生变化时，会自动更新 DOM。</p>
<p>有时，我们会在对象上面设置内部属性，属性名的第一个字符使用下划线开头，表示这些属性不应该被外部使用。结合<code>get</code>和<code>set</code>方法，就可以做到防止这些内部属性被外部读写。</p>
<pre><code class="javascript">const handler = &#123;
  get (target, key) &#123;
    invariant(key, &#39;get&#39;);
    return target[key];
  &#125;,
  set (target, key, value) &#123;
    invariant(key, &#39;set&#39;);
    target[key] = value;
    return true;
  &#125;
&#125;;
function invariant (key, action) &#123;
  if (key[0] === &#39;_&#39;) &#123;
    throw new Error(`Invalid attempt to $&#123;action&#125; private &quot;$&#123;key&#125;&quot; property`);
  &#125;
&#125;
const target = &#123;&#125;;
const proxy = new Proxy(target, handler);
proxy._prop
// Error: Invalid attempt to get private &quot;_prop&quot; property
proxy._prop = &#39;c&#39;
// Error: Invalid attempt to set private &quot;_prop&quot; property</code></pre>
<p>上面代码中，只要读写的属性名的第一个字符是下划线，一律抛错，从而达到禁止读写内部属性的目的。</p>
<p>下面是<code>set</code>方法第四个参数的例子。</p>
<pre><code class="javascript">const handler = &#123;
  set: function(obj, prop, value, receiver) &#123;
    obj[prop] = receiver;
  &#125;
&#125;;
const proxy = new Proxy(&#123;&#125;, handler);
proxy.foo = &#39;bar&#39;;
proxy.foo === proxy // true</code></pre>
<p>上面代码中，<code>set</code>方法的第四个参数<code>receiver</code>，指的是原始的操作行为所在的那个对象，一般情况下是<code>proxy</code>实例本身，请看下面的例子。</p>
<pre><code class="javascript">const handler = &#123;
  set: function(obj, prop, value, receiver) &#123;
    obj[prop] = receiver;
  &#125;
&#125;;
const proxy = new Proxy(&#123;&#125;, handler);
const myObj = &#123;&#125;;
Object.setPrototypeOf(myObj, proxy);

myObj.foo = &#39;bar&#39;;
myObj.foo === myObj // true</code></pre>
<p>上面代码中，设置<code>myObj.foo</code>属性的值时，<code>myObj</code>并没有<code>foo</code>属性，因此引擎会到<code>myObj</code>的原型链去找<code>foo</code>属性。<code>myObj</code>的原型对象<code>proxy</code>是一个 Proxy 实例，设置它的<code>foo</code>属性会触发<code>set</code>方法。这时，第四个参数<code>receiver</code>就指向原始赋值行为所在的对象<code>myObj</code>。</p>
<p>注意，如果目标对象自身的某个属性不可写，那么<code>set</code>方法将不起作用。</p>
<pre><code class="javascript">const obj = &#123;&#125;;
Object.defineProperty(obj, &#39;foo&#39;, &#123;
  value: &#39;bar&#39;,
  writable: false
&#125;);

const handler = &#123;
  set: function(obj, prop, value, receiver) &#123;
    obj[prop] = &#39;baz&#39;;
  &#125;
&#125;;

const proxy = new Proxy(obj, handler);
proxy.foo = &#39;baz&#39;;
proxy.foo // &quot;bar&quot;</code></pre>
<p>上面代码中，<code>obj.foo</code>属性不可写，Proxy 对这个属性的<code>set</code>代理将不会生效。</p>
<p>注意，严格模式下，<code>set</code>代理如果没有返回<code>true</code>，就会报错。</p>
<pre><code class="javascript">&#39;use strict&#39;;
const handler = &#123;
  set: function(obj, prop, value, receiver) &#123;
    obj[prop] = receiver;
    // 无论有没有下面这一行，都会报错
    return false;
  &#125;
&#125;;
const proxy = new Proxy(&#123;&#125;, handler);
proxy.foo = &#39;bar&#39;;
// TypeError: &#39;set&#39; on proxy: trap returned falsish for property &#39;foo&#39;</code></pre>
<p>上面代码中，严格模式下，<code>set</code>代理返回<code>false</code>或者<code>undefined</code>，都会报错。</p>
<h3 id="apply"><a href="#apply" class="headerlink" title="apply()"></a>apply()</h3><p><code>apply</code>方法拦截函数的调用、<code>call</code>和<code>apply</code>操作。</p>
<p><code>apply</code>方法可以接受三个参数，分别是目标对象、目标对象的上下文对象（<code>this</code>）和目标对象的参数数组。</p>
<pre><code class="javascript">var handler = &#123;
  apply (target, ctx, args) &#123;
    return Reflect.apply(...arguments);
  &#125;
&#125;;</code></pre>
<p>下面是一个例子。</p>
<pre><code class="javascript">var target = function () &#123; return &#39;I am the target&#39;; &#125;;
var handler = &#123;
  apply: function () &#123;
    return &#39;I am the proxy&#39;;
  &#125;
&#125;;

var p = new Proxy(target, handler);

p()
// &quot;I am the proxy&quot;</code></pre>
<p>上面代码中，变量<code>p</code>是 Proxy 的实例，当它作为函数调用时（<code>p()</code>），就会被<code>apply</code>方法拦截，返回一个字符串。</p>
<p>下面是另外一个例子。</p>
<pre><code class="javascript">var twice = &#123;
  apply (target, ctx, args) &#123;
    return Reflect.apply(...arguments) * 2;
  &#125;
&#125;;
function sum (left, right) &#123;
  return left + right;
&#125;;
var proxy = new Proxy(sum, twice);
proxy(1, 2) // 6
proxy.call(null, 5, 6) // 22
proxy.apply(null, [7, 8]) // 30</code></pre>
<p>上面代码中，每当执行<code>proxy</code>函数（直接调用或<code>call</code>和<code>apply</code>调用），就会被<code>apply</code>方法拦截。</p>
<p>另外，直接调用<code>Reflect.apply</code>方法，也会被拦截。</p>
<pre><code class="javascript">Reflect.apply(proxy, null, [9, 10]) // 38</code></pre>
<h3 id="has"><a href="#has" class="headerlink" title="has()"></a>has()</h3><p><code>has()</code>方法用来拦截<code>HasProperty</code>操作，即判断对象是否具有某个属性时，这个方法会生效。典型的操作就是<code>in</code>运算符。</p>
<p><code>has()</code>方法可以接受两个参数，分别是目标对象、需查询的属性名。</p>
<p>下面的例子使用<code>has()</code>方法隐藏某些属性，不被<code>in</code>运算符发现。</p>
<pre><code class="javascript">var handler = &#123;
  has (target, key) &#123;
    if (key[0] === &#39;_&#39;) &#123;
      return false;
    &#125;
    return key in target;
  &#125;
&#125;;
var target = &#123; _prop: &#39;foo&#39;, prop: &#39;foo&#39; &#125;;
var proxy = new Proxy(target, handler);
&#39;_prop&#39; in proxy // false</code></pre>
<p>上面代码中，如果原对象的属性名的第一个字符是下划线，<code>proxy.has()</code>就会返回<code>false</code>，从而不会被<code>in</code>运算符发现。</p>
<p>如果原对象不可配置或者禁止扩展，这时<code>has()</code>拦截会报错。</p>
<pre><code class="javascript">var obj = &#123; a: 10 &#125;;
Object.preventExtensions(obj);

var p = new Proxy(obj, &#123;
  has: function(target, prop) &#123;
    return false;
  &#125;
&#125;);

&#39;a&#39; in p // TypeError is thrown</code></pre>
<p>上面代码中，<code>obj</code>对象禁止扩展，结果使用<code>has</code>拦截就会报错。也就是说，如果某个属性不可配置（或者目标对象不可扩展），则<code>has()</code>方法就不得“隐藏”（即返回<code>false</code>）目标对象的该属性。</p>
<p>值得注意的是，<code>has()</code>方法拦截的是<code>HasProperty</code>操作，而不是<code>HasOwnProperty</code>操作，即<code>has()</code>方法不判断一个属性是对象自身的属性，还是继承的属性。</p>
<p>另外，虽然<code>for...in</code>循环也用到了<code>in</code>运算符，但是<code>has()</code>拦截对<code>for...in</code>循环不生效。</p>
<pre><code class="javascript">let stu1 = &#123;name: &#39;张三&#39;, score: 59&#125;;
let stu2 = &#123;name: &#39;李四&#39;, score: 99&#125;;

let handler = &#123;
  has(target, prop) &#123;
    if (prop === &#39;score&#39; &amp;&amp; target[prop] &lt; 60) &#123;
      console.log(`$&#123;target.name&#125; 不及格`);
      return false;
    &#125;
    return prop in target;
  &#125;
&#125;

let oproxy1 = new Proxy(stu1, handler);
let oproxy2 = new Proxy(stu2, handler);

&#39;score&#39; in oproxy1
// 张三 不及格
// false

&#39;score&#39; in oproxy2
// true

for (let a in oproxy1) &#123;
  console.log(oproxy1[a]);
&#125;
// 张三
// 59

for (let b in oproxy2) &#123;
  console.log(oproxy2[b]);
&#125;
// 李四
// 99</code></pre>
<p>上面代码中，<code>has()</code>拦截只对<code>in</code>运算符生效，对<code>for...in</code>循环不生效，导致不符合要求的属性没有被<code>for...in</code>循环所排除。</p>
<h3 id="construct"><a href="#construct" class="headerlink" title="construct()"></a>construct()</h3><p><code>construct()</code>方法用于拦截<code>new</code>命令，下面是拦截对象的写法。</p>
<pre><code class="javascript">const handler = &#123;
  construct (target, args, newTarget) &#123;
    return new target(...args);
  &#125;
&#125;;</code></pre>
<p><code>construct()</code>方法可以接受三个参数。</p>
<ul>
<li><code>target</code>：目标对象。</li>
<li><code>args</code>：构造函数的参数数组。</li>
<li><code>newTarget</code>：创造实例对象时，<code>new</code>命令作用的构造函数（下面例子的<code>p</code>）。</li>
</ul>
<pre><code class="javascript">const p = new Proxy(function () &#123;&#125;, &#123;
  construct: function(target, args) &#123;
    console.log(&#39;called: &#39; + args.join(&#39;, &#39;));
    return &#123; value: args[0] * 10 &#125;;
  &#125;
&#125;);

(new p(1)).value
// &quot;called: 1&quot;
// 10</code></pre>
<p><code>construct()</code>方法返回的必须是一个对象，否则会报错。</p>
<pre><code class="javascript">const p = new Proxy(function() &#123;&#125;, &#123;
  construct: function(target, argumentsList) &#123;
    return 1;
  &#125;
&#125;);

new p() // 报错
// Uncaught TypeError: &#39;construct&#39; on proxy: trap returned non-object (&#39;1&#39;)</code></pre>
<p>另外，由于<code>construct()</code>拦截的是构造函数，所以它的目标对象必须是函数，否则就会报错。</p>
<pre><code class="javascript">const p = new Proxy(&#123;&#125;, &#123;
  construct: function(target, argumentsList) &#123;
    return &#123;&#125;;
  &#125;
&#125;);

new p() // 报错
// Uncaught TypeError: p is not a constructor</code></pre>
<p>上面例子中，拦截的目标对象不是一个函数，而是一个对象（<code>new Proxy()</code>的第一个参数），导致报错。</p>
<p>注意，<code>construct()</code>方法中的<code>this</code>指向的是<code>handler</code>，而不是实例对象。</p>
<pre><code class="javascript">const handler = &#123;
  construct: function(target, args) &#123;
    console.log(this === handler);
    return new target(...args);
  &#125;
&#125;

let p = new Proxy(function () &#123;&#125;, handler);
new p() // true</code></pre>
<h3 id="deleteProperty"><a href="#deleteProperty" class="headerlink" title="deleteProperty()"></a>deleteProperty()</h3><p><code>deleteProperty</code>方法用于拦截<code>delete</code>操作，如果这个方法抛出错误或者返回<code>false</code>，当前属性就无法被<code>delete</code>命令删除。</p>
<pre><code class="javascript">var handler = &#123;
  deleteProperty (target, key) &#123;
    invariant(key, &#39;delete&#39;);
    delete target[key];
    return true;
  &#125;
&#125;;
function invariant (key, action) &#123;
  if (key[0] === &#39;_&#39;) &#123;
    throw new Error(`Invalid attempt to $&#123;action&#125; private &quot;$&#123;key&#125;&quot; property`);
  &#125;
&#125;

var target = &#123; _prop: &#39;foo&#39; &#125;;
var proxy = new Proxy(target, handler);
delete proxy._prop
// Error: Invalid attempt to delete private &quot;_prop&quot; property</code></pre>
<p>上面代码中，<code>deleteProperty</code>方法拦截了<code>delete</code>操作符，删除第一个字符为下划线的属性会报错。</p>
<p>注意，目标对象自身的不可配置（configurable）的属性，不能被<code>deleteProperty</code>方法删除，否则报错。</p>
<h3 id="defineProperty"><a href="#defineProperty" class="headerlink" title="defineProperty()"></a>defineProperty()</h3><p><code>defineProperty()</code>方法拦截了<code>Object.defineProperty()</code>操作。</p>
<pre><code class="javascript">var handler = &#123;
  defineProperty (target, key, descriptor) &#123;
    return false;
  &#125;
&#125;;
var target = &#123;&#125;;
var proxy = new Proxy(target, handler);
proxy.foo = &#39;bar&#39; // 不会生效</code></pre>
<p>上面代码中，<code>defineProperty()</code>方法内部没有任何操作，只返回<code>false</code>，导致添加新属性总是无效。注意，这里的<code>false</code>只是用来提示操作失败，本身并不能阻止添加新属性。</p>
<p>注意，如果目标对象不可扩展（non-extensible），则<code>defineProperty()</code>不能增加目标对象上不存在的属性，否则会报错。另外，如果目标对象的某个属性不可写（writable）或不可配置（configurable），则<code>defineProperty()</code>方法不得改变这两个设置。</p>
<h3 id="getOwnPropertyDescriptor"><a href="#getOwnPropertyDescriptor" class="headerlink" title="getOwnPropertyDescriptor()"></a>getOwnPropertyDescriptor()</h3><p><code>getOwnPropertyDescriptor()</code>方法拦截<code>Object.getOwnPropertyDescriptor()</code>，返回一个属性描述对象或者<code>undefined</code>。</p>
<pre><code class="javascript">var handler = &#123;
  getOwnPropertyDescriptor (target, key) &#123;
    if (key[0] === &#39;_&#39;) &#123;
      return;
    &#125;
    return Object.getOwnPropertyDescriptor(target, key);
  &#125;
&#125;;
var target = &#123; _foo: &#39;bar&#39;, baz: &#39;tar&#39; &#125;;
var proxy = new Proxy(target, handler);
Object.getOwnPropertyDescriptor(proxy, &#39;wat&#39;)
// undefined
Object.getOwnPropertyDescriptor(proxy, &#39;_foo&#39;)
// undefined
Object.getOwnPropertyDescriptor(proxy, &#39;baz&#39;)
// &#123; value: &#39;tar&#39;, writable: true, enumerable: true, configurable: true &#125;</code></pre>
<p>上面代码中，<code>handler.getOwnPropertyDescriptor()</code>方法对于第一个字符为下划线的属性名会返回<code>undefined</code>。</p>
<h3 id="getPrototypeOf"><a href="#getPrototypeOf" class="headerlink" title="getPrototypeOf()"></a>getPrototypeOf()</h3><p><code>getPrototypeOf()</code>方法主要用来拦截获取对象原型。具体来说，拦截下面这些操作。</p>
<ul>
<li><code>Object.prototype.__proto__</code></li>
<li><code>Object.prototype.isPrototypeOf()</code></li>
<li><code>Object.getPrototypeOf()</code></li>
<li><code>Reflect.getPrototypeOf()</code></li>
<li><code>instanceof</code></li>
</ul>
<p>下面是一个例子。</p>
<pre><code class="javascript">var proto = &#123;&#125;;
var p = new Proxy(&#123;&#125;, &#123;
  getPrototypeOf(target) &#123;
    return proto;
  &#125;
&#125;);
Object.getPrototypeOf(p) === proto // true</code></pre>
<p>上面代码中，<code>getPrototypeOf()</code>方法拦截<code>Object.getPrototypeOf()</code>，返回<code>proto</code>对象。</p>
<p>注意，<code>getPrototypeOf()</code>方法的返回值必须是对象或者<code>null</code>，否则报错。另外，如果目标对象不可扩展（non-extensible）， <code>getPrototypeOf()</code>方法必须返回目标对象的原型对象。</p>
<h3 id="isExtensible"><a href="#isExtensible" class="headerlink" title="isExtensible()"></a>isExtensible()</h3><p><code>isExtensible()</code>方法拦截<code>Object.isExtensible()</code>操作。</p>
<pre><code class="javascript">var p = new Proxy(&#123;&#125;, &#123;
  isExtensible: function(target) &#123;
    console.log(&quot;called&quot;);
    return true;
  &#125;
&#125;);

Object.isExtensible(p)
// &quot;called&quot;
// true</code></pre>
<p>上面代码设置了<code>isExtensible()</code>方法，在调用<code>Object.isExtensible</code>时会输出<code>called</code>。</p>
<p>注意，该方法只能返回布尔值，否则返回值会被自动转为布尔值。</p>
<p>这个方法有一个强限制，它的返回值必须与目标对象的<code>isExtensible</code>属性保持一致，否则就会抛出错误。</p>
<pre><code class="javascript">Object.isExtensible(proxy) === Object.isExtensible(target)</code></pre>
<p>下面是一个例子。</p>
<pre><code class="javascript">var p = new Proxy(&#123;&#125;, &#123;
  isExtensible: function(target) &#123;
    return false;
  &#125;
&#125;);

Object.isExtensible(p)
// Uncaught TypeError: &#39;isExtensible&#39; on proxy: trap result does not reflect extensibility of proxy target (which is &#39;true&#39;)</code></pre>
<h3 id="ownKeys"><a href="#ownKeys" class="headerlink" title="ownKeys()"></a>ownKeys()</h3><p><code>ownKeys()</code>方法用来拦截对象自身属性的读取操作。具体来说，拦截以下操作。</p>
<ul>
<li><code>Object.getOwnPropertyNames()</code></li>
<li><code>Object.getOwnPropertySymbols()</code></li>
<li><code>Object.keys()</code></li>
<li><code>for...in</code>循环</li>
</ul>
<p>下面是拦截<code>Object.keys()</code>的例子。</p>
<pre><code class="javascript">let target = &#123;
  a: 1,
  b: 2,
  c: 3
&#125;;

let handler = &#123;
  ownKeys(target) &#123;
    return [&#39;a&#39;];
  &#125;
&#125;;

let proxy = new Proxy(target, handler);

Object.keys(proxy)
// [ &#39;a&#39; ]</code></pre>
<p>上面代码拦截了对于<code>target</code>对象的<code>Object.keys()</code>操作，只返回<code>a</code>、<code>b</code>、<code>c</code>三个属性之中的<code>a</code>属性。</p>
<p>下面的例子是拦截第一个字符为下划线的属性名。</p>
<pre><code class="javascript">let target = &#123;
  _bar: &#39;foo&#39;,
  _prop: &#39;bar&#39;,
  prop: &#39;baz&#39;
&#125;;

let handler = &#123;
  ownKeys (target) &#123;
    return Reflect.ownKeys(target).filter(key =&gt; key[0] !== &#39;_&#39;);
  &#125;
&#125;;

let proxy = new Proxy(target, handler);
for (let key of Object.keys(proxy)) &#123;
  console.log(target[key]);
&#125;
// &quot;baz&quot;</code></pre>
<p>注意，使用<code>Object.keys()</code>方法时，有三类属性会被<code>ownKeys()</code>方法自动过滤，不会返回。</p>
<ul>
<li>目标对象上不存在的属性</li>
<li>属性名为 Symbol 值</li>
<li>不可遍历（<code>enumerable</code>）的属性</li>
</ul>
<pre><code class="javascript">let target = &#123;
  a: 1,
  b: 2,
  c: 3,
  [Symbol.for(&#39;secret&#39;)]: &#39;4&#39;,
&#125;;

Object.defineProperty(target, &#39;key&#39;, &#123;
  enumerable: false,
  configurable: true,
  writable: true,
  value: &#39;static&#39;
&#125;);

let handler = &#123;
  ownKeys(target) &#123;
    return [&#39;a&#39;, &#39;d&#39;, Symbol.for(&#39;secret&#39;), &#39;key&#39;];
  &#125;
&#125;;

let proxy = new Proxy(target, handler);

Object.keys(proxy)
// [&#39;a&#39;]</code></pre>
<p>上面代码中，<code>ownKeys()</code>方法之中，显式返回不存在的属性（<code>d</code>）、Symbol 值（<code>Symbol.for(&#39;secret&#39;)</code>）、不可遍历的属性（<code>key</code>），结果都被自动过滤掉。</p>
<p><code>ownKeys()</code>方法还可以拦截<code>Object.getOwnPropertyNames()</code>。</p>
<pre><code class="javascript">var p = new Proxy(&#123;&#125;, &#123;
  ownKeys: function(target) &#123;
    return [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];
  &#125;
&#125;);

Object.getOwnPropertyNames(p)
// [ &#39;a&#39;, &#39;b&#39;, &#39;c&#39; ]</code></pre>
<p><code>for...in</code>循环也受到<code>ownKeys()</code>方法的拦截。</p>
<pre><code class="javascript">const obj = &#123; hello: &#39;world&#39; &#125;;
const proxy = new Proxy(obj, &#123;
  ownKeys: function () &#123;
    return [&#39;a&#39;, &#39;b&#39;];
  &#125;
&#125;);

for (let key in proxy) &#123;
  console.log(key); // 没有任何输出
&#125;</code></pre>
<p>上面代码中，<code>ownkeys()</code>指定只返回<code>a</code>和<code>b</code>属性，由于<code>obj</code>没有这两个属性，因此<code>for...in</code>循环不会有任何输出。</p>
<p><code>ownKeys()</code>方法返回的数组成员，只能是字符串或 Symbol 值。如果有其他类型的值，或者返回的根本不是数组，就会报错。</p>
<pre><code class="javascript">var obj = &#123;&#125;;

var p = new Proxy(obj, &#123;
  ownKeys: function(target) &#123;
    return [123, true, undefined, null, &#123;&#125;, []];
  &#125;
&#125;);

Object.getOwnPropertyNames(p)
// Uncaught TypeError: 123 is not a valid property name</code></pre>
<p>上面代码中，<code>ownKeys()</code>方法虽然返回一个数组，但是每一个数组成员都不是字符串或 Symbol 值，因此就报错了。</p>
<p>如果目标对象自身包含不可配置的属性，则该属性必须被<code>ownKeys()</code>方法返回，否则报错。</p>
<pre><code class="javascript">var obj = &#123;&#125;;
Object.defineProperty(obj, &#39;a&#39;, &#123;
  configurable: false,
  enumerable: true,
  value: 10 &#125;
);

var p = new Proxy(obj, &#123;
  ownKeys: function(target) &#123;
    return [&#39;b&#39;];
  &#125;
&#125;);

Object.getOwnPropertyNames(p)
// Uncaught TypeError: &#39;ownKeys&#39; on proxy: trap result did not include &#39;a&#39;</code></pre>
<p>上面代码中，<code>obj</code>对象的<code>a</code>属性是不可配置的，这时<code>ownKeys()</code>方法返回的数组之中，必须包含<code>a</code>，否则会报错。</p>
<p>另外，如果目标对象是不可扩展的（non-extensible），这时<code>ownKeys()</code>方法返回的数组之中，必须包含原对象的所有属性，且不能包含多余的属性，否则报错。</p>
<pre><code class="javascript">var obj = &#123;
  a: 1
&#125;;

Object.preventExtensions(obj);

var p = new Proxy(obj, &#123;
  ownKeys: function(target) &#123;
    return [&#39;a&#39;, &#39;b&#39;];
  &#125;
&#125;);

Object.getOwnPropertyNames(p)
// Uncaught TypeError: &#39;ownKeys&#39; on proxy: trap returned extra keys but proxy target is non-extensible</code></pre>
<p>上面代码中，<code>obj</code>对象是不可扩展的，这时<code>ownKeys()</code>方法返回的数组之中，包含了<code>obj</code>对象的多余属性<code>b</code>，所以导致了报错。</p>
<h3 id="preventExtensions"><a href="#preventExtensions" class="headerlink" title="preventExtensions()"></a>preventExtensions()</h3><p><code>preventExtensions()</code>方法拦截<code>Object.preventExtensions()</code>。该方法必须返回一个布尔值，否则会被自动转为布尔值。</p>
<p>这个方法有一个限制，只有目标对象不可扩展时（即<code>Object.isExtensible(proxy)</code>为<code>false</code>），<code>proxy.preventExtensions</code>才能返回<code>true</code>，否则会报错。</p>
<pre><code class="javascript">var proxy = new Proxy(&#123;&#125;, &#123;
  preventExtensions: function(target) &#123;
    return true;
  &#125;
&#125;);

Object.preventExtensions(proxy)
// Uncaught TypeError: &#39;preventExtensions&#39; on proxy: trap returned truish but the proxy target is extensible</code></pre>
<p>上面代码中，<code>proxy.preventExtensions()</code>方法返回<code>true</code>，但这时<code>Object.isExtensible(proxy)</code>会返回<code>true</code>，因此报错。</p>
<p>为了防止出现这个问题，通常要在<code>proxy.preventExtensions()</code>方法里面，调用一次<code>Object.preventExtensions()</code>。</p>
<pre><code class="javascript">var proxy = new Proxy(&#123;&#125;, &#123;
  preventExtensions: function(target) &#123;
    console.log(&#39;called&#39;);
    Object.preventExtensions(target);
    return true;
  &#125;
&#125;);

Object.preventExtensions(proxy)
// &quot;called&quot;
// Proxy &#123;&#125;</code></pre>
<h3 id="setPrototypeOf"><a href="#setPrototypeOf" class="headerlink" title="setPrototypeOf()"></a>setPrototypeOf()</h3><p><code>setPrototypeOf()</code>方法主要用来拦截<code>Object.setPrototypeOf()</code>方法。</p>
<p>下面是一个例子。</p>
<pre><code class="javascript">var handler = &#123;
  setPrototypeOf (target, proto) &#123;
    throw new Error(&#39;Changing the prototype is forbidden&#39;);
  &#125;
&#125;;
var proto = &#123;&#125;;
var target = function () &#123;&#125;;
var proxy = new Proxy(target, handler);
Object.setPrototypeOf(proxy, proto);
// Error: Changing the prototype is forbidden</code></pre>
<p>上面代码中，只要修改<code>target</code>的原型对象，就会报错。</p>
<p>注意，该方法只能返回布尔值，否则会被自动转为布尔值。另外，如果目标对象不可扩展（non-extensible），<code>setPrototypeOf()</code>方法不得改变目标对象的原型。</p>
<h2 id="Proxy-revocable"><a href="#Proxy-revocable" class="headerlink" title="Proxy.revocable()"></a>Proxy.revocable()</h2><p><code>Proxy.revocable()</code>方法返回一个可取消的 Proxy 实例。</p>
<pre><code class="javascript">let target = &#123;&#125;;
let handler = &#123;&#125;;

let &#123;proxy, revoke&#125; = Proxy.revocable(target, handler);

proxy.foo = 123;
proxy.foo // 123

revoke();
proxy.foo // TypeError: Revoked</code></pre>
<p><code>Proxy.revocable()</code>方法返回一个对象，该对象的<code>proxy</code>属性是<code>Proxy</code>实例，<code>revoke</code>属性是一个函数，可以取消<code>Proxy</code>实例。上面代码中，当执行<code>revoke</code>函数之后，再访问<code>Proxy</code>实例，就会抛出一个错误。</p>
<p><code>Proxy.revocable()</code>的一个使用场景是，目标对象不允许直接访问，必须通过代理访问，一旦访问结束，就收回代理权，不允许再次访问。</p>
<h2 id="this-问题"><a href="#this-问题" class="headerlink" title="this 问题"></a>this 问题</h2><p>虽然 Proxy 可以代理针对目标对象的访问，但它不是目标对象的透明代理，即不做任何拦截的情况下，也无法保证与目标对象的行为一致。主要原因就是在 Proxy 代理的情况下，目标对象内部的<code>this</code>关键字会指向 Proxy 代理。</p>
<pre><code class="javascript">const target = &#123;
  m: function () &#123;
    console.log(this === proxy);
  &#125;
&#125;;
const handler = &#123;&#125;;

const proxy = new Proxy(target, handler);

target.m() // false
proxy.m()  // true</code></pre>
<p>上面代码中，一旦<code>proxy</code>代理<code>target</code>，<code>target.m()</code>内部的<code>this</code>就是指向<code>proxy</code>，而不是<code>target</code>。</p>
<p>下面是一个例子，由于<code>this</code>指向的变化，导致 Proxy 无法代理目标对象。</p>
<pre><code class="javascript">const _name = new WeakMap();

class Person &#123;
  constructor(name) &#123;
    _name.set(this, name);
  &#125;
  get name() &#123;
    return _name.get(this);
  &#125;
&#125;

const jane = new Person(&#39;Jane&#39;);
jane.name // &#39;Jane&#39;

const proxy = new Proxy(jane, &#123;&#125;);
proxy.name // undefined</code></pre>
<p>上面代码中，目标对象<code>jane</code>的<code>name</code>属性，实际保存在外部<code>WeakMap</code>对象<code>_name</code>上面，通过<code>this</code>键区分。由于通过<code>proxy.name</code>访问时，<code>this</code>指向<code>proxy</code>，导致无法取到值，所以返回<code>undefined</code>。</p>
<p>此外，有些原生对象的内部属性，只有通过正确的<code>this</code>才能拿到，所以 Proxy 也无法代理这些原生对象的属性。</p>
<pre><code class="javascript">const target = new Date();
const handler = &#123;&#125;;
const proxy = new Proxy(target, handler);

proxy.getDate();
// TypeError: this is not a Date object.</code></pre>
<p>上面代码中，<code>getDate()</code>方法只能在<code>Date</code>对象实例上面拿到，如果<code>this</code>不是<code>Date</code>对象实例就会报错。这时，<code>this</code>绑定原始对象，就可以解决这个问题。</p>
<pre><code class="javascript">const target = new Date(&#39;2015-01-01&#39;);
const handler = &#123;
  get(target, prop) &#123;
    if (prop === &#39;getDate&#39;) &#123;
      return target.getDate.bind(target);
    &#125;
    return Reflect.get(target, prop);
  &#125;
&#125;;
const proxy = new Proxy(target, handler);

proxy.getDate() // 1</code></pre>
<p>另外，Proxy 拦截函数内部的<code>this</code>，指向的是<code>handler</code>对象。</p>
<pre><code class="javascript">const handler = &#123;
  get: function (target, key, receiver) &#123;
    console.log(this === handler);
    return &#39;Hello, &#39; + key;
  &#125;,
  set: function (target, key, value) &#123;
    console.log(this === handler);
    target[key] = value;
    return true;
  &#125;
&#125;;

const proxy = new Proxy(&#123;&#125;, handler);

proxy.foo
// true
// Hello, foo

proxy.foo = 1
// true</code></pre>
<p>上面例子中，<code>get()</code>和<code>set()</code>拦截函数内部的<code>this</code>，指向的都是<code>handler</code>对象。</p>
<h2 id="实例：Web-服务的客户端"><a href="#实例：Web-服务的客户端" class="headerlink" title="实例：Web 服务的客户端"></a>实例：Web 服务的客户端</h2><p>Proxy 对象可以拦截目标对象的任意属性，这使得它很合适用来写 Web 服务的客户端。</p>
<pre><code class="javascript">const service = createWebService(&#39;http://example.com/data&#39;);

service.employees().then(json =&gt; &#123;
  const employees = JSON.parse(json);
  // ···
&#125;);</code></pre>
<p>上面代码新建了一个 Web 服务的接口，这个接口返回各种数据。Proxy 可以拦截这个对象的任意属性，所以不用为每一种数据写一个适配方法，只要写一个 Proxy 拦截就可以了。</p>
<pre><code class="javascript">function createWebService(baseUrl) &#123;
  return new Proxy(&#123;&#125;, &#123;
    get(target, propKey, receiver) &#123;
      return () =&gt; httpGet(baseUrl + &#39;/&#39; + propKey);
    &#125;
  &#125;);
&#125;</code></pre>
<p>同理，Proxy 也可以用来实现数据库的 ORM 层。</p>
]]></content>
      <tags>
        <tag>proxy代理</tag>
      </tags>
  </entry>
</search>

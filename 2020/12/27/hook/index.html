<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>hook的整理使用 | Hexo</title>
  <meta name="keywords" content="">
  <meta name="description" content="hook的整理使用 | Hexo">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick">
<meta property="og:type" content="website">
<meta property="og:title" content="Hello World">
<meta property="og:url" content="http://example.com/hello-world.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-12-27T11:39:36.762Z">
<meta property="article:modified_time" content="2020-12-27T11:39:36.762Z">
<meta property="article:author" content="前端菜鸟">
<meta name="twitter:card" content="summary">


<link rel="icon" href="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=3014093926,41837070&fm=26&gp=0.jpg">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/atom-light.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 5.3.0"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/" class="avatar_target">
    <img class="avatar" src="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=3014093926,41837070&amp;fm=26&amp;gp=0.jpg" />
</a>
<div class="author">
    <span>前端菜鸟</span>
</div>

<div class="icon">
    
        
        <a title="rss" href="/atom.xml" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-rss"></use>
                </svg>
            
        </a>
        
    
        
        <a title="github" href="https://github.com/18801214376lk" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-github"></use>
                </svg>
            
        </a>
        
    
        
    
        
    
        
        <a title="weibo" href="https://weibo.com/u/7384469670/home?wvr=5" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-weibo"></use>
                </svg>
            
        </a>
        
    
        
    
        
    
        
    
        
        <a title="juejin" href="https://juejin.cn/user/4344919342731837" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-juejin"></use>
                </svg>
            
        </a>
        
    
        
        <a title="email" href="mailto:18801214376@qq.com" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-email"></use>
                </svg>
            
        </a>
        
    
        
        <a title="qq" href="http://wpa.qq.com/msgrd?v=3&uin=2655883468&site=qq&menu=yes" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-qq"></use>
                </svg>
            
        </a>
        
    
        
        <a title="kugou" href="https://www.kugou.com/" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-kugou"></use>
                </svg>
            
        </a>
        
    
</div>



<a class="more-menus">更多菜单</a>


<ul>
    <li><div class="all active" data-rel="All">All<small>(7)</small></div></li>
    
</ul>
<div class="left-bottom">
    <div class="menus">
    
    
    <a class="dynamic-menu site_url"   href="/photo">相册</a>
    
    
    
    </div>
    <div><a class="about  hasFriend  site_url"  href="/about">五福临门</a><a style="width: 50%"  class="friends">小白</a></div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="7">

<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        Links
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">All</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" />
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>proxy代理</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>前端</a>
            </li>
        
    </div>

</div>

    
    <nav id="title-list-nav">
        
        <a  class="All "
           href="/2021/01/25/proxy/"
           data-tag="proxy代理"
           data-author="" >
            <span class="post-title" title="proxy">proxy</span>
            <span class="post-date" title="2021-01-25 21:07:06">2021/01/25</span>
        </a>
        
        <a  class="All "
           href="/2021/01/11/%E5%90%8C%E6%BA%90%E5%8F%8A%E8%B7%A8%E5%9F%9F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="同源及跨域">同源及跨域</span>
            <span class="post-date" title="2021-01-11 15:23:43">2021/01/11</span>
        </a>
        
        <a  class="All "
           href="/2021/01/04/Object/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="TypeScript">TypeScript</span>
            <span class="post-date" title="2021-01-04 08:30:13">2021/01/04</span>
        </a>
        
        <a  class="All "
           href="/2020/12/30/TypeScript/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="TypeScript">TypeScript</span>
            <span class="post-date" title="2020-12-30 08:30:13">2020/12/30</span>
        </a>
        
        <a  class="All "
           href="/2020/12/30/%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/"
           data-tag="前端"
           data-author="" >
            <span class="post-title" title="JavaScript的严格模式">JavaScript的严格模式</span>
            <span class="post-date" title="2020-12-30 08:30:13">2020/12/30</span>
        </a>
        
        <a  class="All "
           href="/2020/12/28/class/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="class的总结">class的总结</span>
            <span class="post-date" title="2020-12-28 20:39:20">2020/12/28</span>
        </a>
        
        <a  class="All "
           href="/2020/12/27/hook/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="hook的整理使用">hook的整理使用</span>
            <span class="post-date" title="2020-12-27 19:40:43">2020/12/27</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>
    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-hook" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">hook的整理使用</h1>
    
    <div class="article-meta">
        
        
        
        
    </div>
    <div class="article-meta">
        
            Created At : <time class="date" title='Updated At: 2021-01-05 19:33:01'>2020-12-27 19:40</time>
        
    </div>
    <div class="article-meta">
        
        
        <span id="busuanzi_container_page_pv">
            Views 👀 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
        <span class="top-comment" title="跳转至评论区">
            <a href="#comments">
                Comment:<span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </a>
        </span>
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#hook%E7%AE%80%E4%BB%8B"><span class="toc-text">hook简介</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#useState%E4%BD%BF%E7%94%A8"><span class="toc-text">useState使用</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#useState"><span class="toc-text">useState</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#useEffect"><span class="toc-text">useEffect</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#useEffect%E6%98%AF%E5%9C%A8%E5%8A%A0%E8%BD%BD%E5%89%8D%E6%88%96%E6%9B%B4%E6%96%B0%E6%97%B6%E9%83%BD%E4%BC%9A%E4%BD%BF%E7%94%A8-%E6%9B%BF%E4%BB%A3%E4%BA%86componentDidMount-%E5%92%8CcomponentDidUpdate-%E9%9B%86%E5%90%88%E8%B5%B7%E6%9D%A5"><span class="toc-text">useEffect是在加载前或更新时都会使用 替代了componentDidMount()和componentDidUpdate() 集合起来</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#useContext-%E6%8E%A5%E6%94%B6%E4%B8%80%E4%B8%AAcontext%E5%AF%B9%E8%B1%A1%E5%B9%B6%E8%BF%94%E5%9B%9E%E5%BD%93%E5%89%8D%E7%9A%84%E5%80%BC"><span class="toc-text">useContext 接收一个context对象并返回当前的值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F-%E4%BB%96%E4%BC%A0%E5%85%A5%E7%9A%84%E5%80%BC%E4%B8%8D%E6%98%AFConsumer-%E6%B6%88%E8%B4%B9%E8%80%85-%E4%B9%9F%E4%B8%8D%E6%98%AFProvider%E7%94%9F%E4%BA%A7%E8%80%85%E8%80%8C%E6%98%AFcontext%E5%AF%B9%E8%B1%A1%E6%9C%AC%E8%BA%AB"><span class="toc-text">注意 : 他传入的值不是Consumer(消费者)也不是Provider生产者而是context对象本身</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%9D%E5%A4%96%E7%9A%84Hook"><span class="toc-text">额外的Hook</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%83%E6%8B%A5%E6%9C%89%E4%B8%89%E4%B8%AA%E5%80%BC%EF%BC%8C%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%80%BC%E6%98%AFreducer%E5%87%BD%E6%95%B0-%E4%BB%96%E4%BC%9A%E8%BF%94%E5%9B%9E%E6%96%B0%E7%9A%84%E5%80%BC%E6%9D%A5%E8%A6%86%E7%9B%96%E5%8E%9F%E6%9D%A5%E7%9A%84%E5%80%BC-%E7%AC%AC%E4%BA%8C%E4%B8%AA%E5%80%BC%E6%98%AF%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E5%8F%82%E6%95%B0%EF%BC%8C%E7%AC%AC%E4%B8%89%E4%B8%AA%E5%80%BC%E6%98%AF%E6%83%B0%E6%80%A7%E5%88%9D%E5%A7%8B%E5%8C%96-%E9%9C%80%E8%A6%81%E5%B0%86-init-%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA-useReducer-%E7%9A%84%E7%AC%AC%E4%B8%89%E4%B8%AA%E5%8F%82%E6%95%B0%E4%BC%A0%E5%85%A5%EF%BC%8C%E8%BF%99%E6%A0%B7%E5%88%9D%E5%A7%8B-state-%E5%B0%86%E8%A2%AB%E8%AE%BE%E7%BD%AE%E4%B8%BA-init-initialArg"><span class="toc-text">它拥有三个值，第一个值是reducer函数,他会返回新的值来覆盖原来的值,第二个值是初始化的参数，第三个值是惰性初始化,需要将 init 函数作为 useReducer 的第三个参数传入，这样初始 state 将被设置为 init(initialArg)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F-%E4%BC%A0%E5%85%A5%E5%87%BD%E6%95%B0%E4%B8%8D%E8%A6%81%E5%9C%A8%E7%94%9F%E6%88%90dom%E7%9A%84%E5%87%BD%E6%95%B0%E4%B8%AD-%E5%90%A6%E5%88%99%E9%A6%96%E6%AC%A1%E8%B0%83%E7%94%A8%E4%BC%9A%E6%89%A7%E8%A1%8C%E4%B8%A4%E5%9B%9E"><span class="toc-text">注意 传入函数不要在生成dom的函数中,否则首次调用会执行两回</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#useCallback"><span class="toc-text">useCallback</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%9A%E5%9C%A8%E7%BB%84%E4%BB%B6%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%B8%B2%E6%9F%93%E7%9A%84%E6%97%B6%E5%80%99%E6%89%A7%E8%A1%8C%EF%BC%8C%E4%B9%8B%E5%90%8E%E4%BC%9A%E5%9C%A8%E5%85%B6%E4%BE%9D%E8%B5%96%E7%9A%84%E5%8F%98%E9%87%8F%E5%8F%91%E7%94%9F%E6%94%B9%E5%8F%98%E6%97%B6%E5%86%8D%E6%AC%A1%E6%89%A7%E8%A1%8C%EF%BC%8C%E5%B9%B6%E4%B8%94%E8%BF%94%E5%9B%9E%E7%BC%93%E5%AD%98%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-text">会在组件第一次渲染的时候执行，之后会在其依赖的变量发生改变时再次执行，并且返回缓存的函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E5%8F%AF%E4%BB%A5%E5%BA%94%E7%94%A8%E5%9C%A8%E7%88%B6%E7%BB%84%E4%BB%B6%E5%90%91%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%8F%82-%E5%BD%93%E7%88%B6%E7%BB%84%E4%BB%B6%E9%87%8C%E9%9D%A2%E7%9A%84%E5%80%BC%E5%8F%98%E5%8C%96%E6%97%B6%EF%BC%8C%E4%BD%BF%E5%AD%90%E7%BB%84%E4%BB%B6%E9%81%BF%E5%85%8D%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E6%9B%B4%E6%96%B0"><span class="toc-text">其可以应用在父组件向子组件传参,当父组件里面的值变化时，使子组件避免不必要的更新</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#useMemo"><span class="toc-text">useMemo</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8useMemo%E6%9D%A5%E6%89%A7%E8%A1%8C%E6%98%82%E8%B4%B5%E7%9A%84%E8%AE%A1%E7%AE%97%EF%BC%8C%E7%84%B6%E5%90%8E%E5%B0%86%E8%AE%A1%E7%AE%97%E5%80%BC%E8%BF%94%E5%9B%9E%EF%BC%8C%E5%B9%B6%E4%B8%94%E5%B0%86count%E4%BD%9C%E4%B8%BA%E4%BE%9D%E8%B5%96%E5%80%BC%E4%BC%A0%E9%80%92%E8%BF%9B%E5%8E%BB%E3%80%82%E8%BF%99%E6%A0%B7%EF%BC%8C%E5%B0%B1%E5%8F%AA%E4%BC%9A%E5%9C%A8count%E6%94%B9%E5%8F%98%E7%9A%84%E6%97%B6%E5%80%99%E8%A7%A6%E5%8F%91expensive%E6%89%A7%E8%A1%8C%EF%BC%8C%E5%9C%A8%E4%BF%AE%E6%94%B9val%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E8%BF%94%E5%9B%9E%E4%B8%8A%E4%B8%80%E6%AC%A1%E7%BC%93%E5%AD%98%E7%9A%84%E5%80%BC%E3%80%82"><span class="toc-text">使用useMemo来执行昂贵的计算，然后将计算值返回，并且将count作为依赖值传递进去。这样，就只会在count改变的时候触发expensive执行，在修改val的时候，返回上一次缓存的值。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#useRef-%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA%E5%8F%AF%E5%8F%98%E7%9A%84-ref-%E5%AF%B9%E8%B1%A1%EF%BC%8C%E5%85%B6-current-%E5%B1%9E%E6%80%A7%E8%A2%AB%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%BA%E4%BC%A0%E5%85%A5%E7%9A%84%E5%8F%82%E6%95%B0%E3%80%82%E8%BF%94%E5%9B%9E%E7%9A%84-ref-%E5%AF%B9%E8%B1%A1%E5%9C%A8%E7%BB%84%E4%BB%B6%E7%9A%84%E6%95%B4%E4%B8%AA%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%86%85%E4%BF%9D%E6%8C%81%E4%B8%8D%E5%8F%98%E3%80%82"><span class="toc-text">useRef  返回一个可变的 ref 对象，其 .current 属性被初始化为传入的参数。返回的 ref 对象在组件的整个生命周期内保持不变。</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90"><span class="toc-text">例子</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%98%E6%9C%89%E5%BE%88%E5%A4%9Ahook%E6%96%B9%E6%B3%95-%E4%BE%8B%E5%A6%82"><span class="toc-text">还有很多hook方法 例如</span></a></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="hook简介"><a href="#hook简介" class="headerlink" title="hook简介"></a>hook简介</h3><font color=#FF0000 >
     Hook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。
</font>

<h5 id="useState使用"><a href="#useState使用" class="headerlink" title="useState使用"></a>useState使用</h5><pre><code>import React, &#123; useState &#125; from &#39;react&#39;;
function Example() &#123;
  // 声明一个新的叫做 “count” 的 state 变量
  const [count, setCount] = useState(0);
  return (
    &lt;div&gt;
      &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;
      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;
        Click me
      &lt;/button&gt;
    &lt;/div&gt;
  );
&#125;</code></pre>
<h2 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h2><font color=#ff0000>
可以实现在函数组件中使用 state count是值,setCount是修改的方法
</font>

<h2 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h2><pre><code>import React, &#123; useState, useEffect &#125; from &#39;react&#39;;

function Example() &#123;
  const [count, setCount] = useState(0);

  // Similar to componentDidMount and componentDidUpdate:
  useEffect(() =&gt; &#123;
    // Update the document title using the browser API
    document.title = `You clicked $&#123;count&#125; times`;
  &#125;);

  return (
    &lt;div&gt;
      &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;
      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;
        Click me
      &lt;/button&gt;
    &lt;/div&gt;
  );
&#125;</code></pre>
<p><strong>&lt;font color==#00000 &gt;很多情况下，我们希望在组件加载和更新时执行同样的操作。从概念上说，我们希望它在每次渲染之后执行 —— 但 React 的 class 组件没有提供这样的方法。即使我们提取出一个方法，我们还是要在两个地方调用它。</font></strong></p>
<h2 id="useEffect是在加载前或更新时都会使用-替代了componentDidMount-和componentDidUpdate-集合起来"><a href="#useEffect是在加载前或更新时都会使用-替代了componentDidMount-和componentDidUpdate-集合起来" class="headerlink" title="useEffect是在加载前或更新时都会使用 替代了componentDidMount()和componentDidUpdate() 集合起来"></a>useEffect是在加载前或更新时都会使用 替代了componentDidMount()和componentDidUpdate() 集合起来</h2><p><font color=red>不要在循环，条件或嵌套函数中调用 Hook， 确保总是在你的 React 函数的最顶层调用他们。遵守这条规则，你就能确保 Hook 在每一次渲染中都按照同样的顺序被调用。这让 React 能够在多次的 useState 和 useEffect 调用之间保持 hook 状态的正确。<br><font/></p>
<h4 id="useContext-接收一个context对象并返回当前的值"><a href="#useContext-接收一个context对象并返回当前的值" class="headerlink" title="useContext 接收一个context对象并返回当前的值"></a>useContext 接收一个context对象并返回当前的值</h4><pre><code> const value = useContext(MyContext);</code></pre>
<h3 id="注意-他传入的值不是Consumer-消费者-也不是Provider生产者而是context对象本身"><a href="#注意-他传入的值不是Consumer-消费者-也不是Provider生产者而是context对象本身" class="headerlink" title="注意 : 他传入的值不是Consumer(消费者)也不是Provider生产者而是context对象本身"></a>注意 : <font color=blue>他传入的值不是Consumer(消费者)也不是Provider生产者而是context对象本身</font></h3><blockquote>
<p>useContext(MyContext) 只是让你能够读取 context 的值以及订阅 context 的变化。你仍然需要在上层组件树中使用 &lt;MyContext.Provider&gt; 来为下层组件提供 context</p>
</blockquote>
<h2 id="额外的Hook"><a href="#额外的Hook" class="headerlink" title="额外的Hook"></a>额外的Hook</h2><ol>
<li>useReducer<pre><code>const [state, dispatch] = useReducer(reducer, initialArg, init);</code></pre>
<h3 id="它拥有三个值，第一个值是reducer函数-他会返回新的值来覆盖原来的值-第二个值是初始化的参数，第三个值是惰性初始化-需要将-init-函数作为-useReducer-的第三个参数传入，这样初始-state-将被设置为-init-initialArg"><a href="#它拥有三个值，第一个值是reducer函数-他会返回新的值来覆盖原来的值-第二个值是初始化的参数，第三个值是惰性初始化-需要将-init-函数作为-useReducer-的第三个参数传入，这样初始-state-将被设置为-init-initialArg" class="headerlink" title="它拥有三个值，第一个值是reducer函数,他会返回新的值来覆盖原来的值,第二个值是初始化的参数，第三个值是惰性初始化,需要将 init 函数作为 useReducer 的第三个参数传入，这样初始 state 将被设置为 init(initialArg)"></a>它拥有三个值，第一个值是reducer函数,他会返回新的值来覆盖原来的值,第二个值是初始化的参数，第三个值是惰性初始化,需要将 init 函数作为 useReducer 的第三个参数传入，这样初始 state 将被设置为 init(initialArg)</h3></li>
</ol>
<h2 id="注意-传入函数不要在生成dom的函数中-否则首次调用会执行两回"><a href="#注意-传入函数不要在生成dom的函数中-否则首次调用会执行两回" class="headerlink" title="注意 传入函数不要在生成dom的函数中,否则首次调用会执行两回"></a>注意 传入函数不要在生成dom的函数中,否则首次调用会执行两回</h2><pre><code>function init(initialCount) &#123;
    return &#123; count: initialCount &#125;;
&#125;
function reducer(state, action) &#123;
    switch (action.type) &#123;
        case &#39;increment&#39;:
          return &#123; count: state.count + 1 &#125;;
        case &#39;decrement&#39;:
          return &#123; count: state.count - 1 &#125;;
        case &#39;reset&#39;:
          return init(action.payload);
        default:
          throw new Error();
    &#125;
&#125;
function Counter(&#123; initialCount &#125;) &#123;
    const [state, dispatch] = useReducer(reducer, initialCount, init);
    return (
        &lt;div&gt;
          Count: &#123;state.count&#125;
          &lt;button
            onClick=&#123;() =&gt; dispatch(&#123; type: &#39;reset&#39;, payload: initialCount &#125;)&#125;&gt;
            Reset
          &lt;/button&gt;
          &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: &#39;decrement&#39; &#125;)&#125;&gt;-&lt;/button&gt;
          &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: &#39;increment&#39; &#125;)&#125;&gt;+&lt;/button&gt;
        &lt;div /&gt;
    );
&#125;</code></pre>
<h3 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h3><pre><code>const [count, setCount] = useState(1);
    const [val, setVal] = useState(&#39;&#39;);
    const [count, setCount] = useState(1);
    const callback = useCallback(() =&gt; &#123;
        console.log(count);
    &#125;, [count]);
    return &lt;div&gt;
        &lt;h4&gt;&#123;count&#125;&lt;/h4&gt;
        &lt;h4&gt;&#123;set.size&#125;&lt;/h4&gt;
        &lt;div&gt;
            &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;+&lt;/button&gt;
            &lt;input value=&#123;val&#125; onChange=&#123;event =&gt; setVal(event.target.value)&#125;/&gt;
        &lt;/div&gt;
    &lt;/div&gt;;
</code></pre>
<ul>
<li>在所依赖的count变化时会返回新的函数,count没有变化时不变<h4 id="会在组件第一次渲染的时候执行，之后会在其依赖的变量发生改变时再次执行，并且返回缓存的函数"><a href="#会在组件第一次渲染的时候执行，之后会在其依赖的变量发生改变时再次执行，并且返回缓存的函数" class="headerlink" title="会在组件第一次渲染的时候执行，之后会在其依赖的变量发生改变时再次执行，并且返回缓存的函数"></a>会在组件第一次渲染的时候执行，之后会在其依赖的变量发生改变时再次执行，并且返回缓存的函数</h4><h3 id="其可以应用在父组件向子组件传参-当父组件里面的值变化时，使子组件避免不必要的更新"><a href="#其可以应用在父组件向子组件传参-当父组件里面的值变化时，使子组件避免不必要的更新" class="headerlink" title="其可以应用在父组件向子组件传参,当父组件里面的值变化时，使子组件避免不必要的更新"></a>其可以应用在父组件向子组件传参,当父组件里面的值变化时，使子组件避免不必要的更新</h3></li>
</ul>
<h2 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h2><pre><code>export default function WithMemo() &#123;
    const [count, setCount] = useState(1);
    const [val, setValue] = useState(&#39;&#39;);
    const expensive = useMemo(() =&gt; &#123;
        console.log(&#39;compute&#39;);
        let sum = 0;
        for (let i = 0; i &lt; count * 100; i++) &#123;
            sum += i;
        &#125;
        return sum;
    &#125;, [count]);

    return &lt;div&gt;
        &lt;h4&gt;&#123;count&#125;-&#123;expensive&#125;&lt;/h4&gt;
        &#123;val&#125;
        &lt;div&gt;
            &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;+c1&lt;/button&gt;
            &lt;input value=&#123;val&#125; onChange=&#123;event =&gt; setValue(event.target.value)&#125;/&gt;
        &lt;/div&gt;
    &lt;/div&gt;;</code></pre>
<ul>
<li> 同上,会在组件第一次渲染的时候执行，之后会在其依赖的变量发生改变时再次执行，并且返回缓存的变量<h3 id="使用useMemo来执行昂贵的计算，然后将计算值返回，并且将count作为依赖值传递进去。这样，就只会在count改变的时候触发expensive执行，在修改val的时候，返回上一次缓存的值。"><a href="#使用useMemo来执行昂贵的计算，然后将计算值返回，并且将count作为依赖值传递进去。这样，就只会在count改变的时候触发expensive执行，在修改val的时候，返回上一次缓存的值。" class="headerlink" title="使用useMemo来执行昂贵的计算，然后将计算值返回，并且将count作为依赖值传递进去。这样，就只会在count改变的时候触发expensive执行，在修改val的时候，返回上一次缓存的值。"></a>使用useMemo来执行昂贵的计算，然后将计算值返回，并且将count作为依赖值传递进去。这样，就只会在count改变的时候触发expensive执行，在修改val的时候，返回上一次缓存的值。</h3></li>
</ul>
<h3 id="useRef-返回一个可变的-ref-对象，其-current-属性被初始化为传入的参数。返回的-ref-对象在组件的整个生命周期内保持不变。"><a href="#useRef-返回一个可变的-ref-对象，其-current-属性被初始化为传入的参数。返回的-ref-对象在组件的整个生命周期内保持不变。" class="headerlink" title="useRef  返回一个可变的 ref 对象，其 .current 属性被初始化为传入的参数。返回的 ref 对象在组件的整个生命周期内保持不变。"></a>useRef  返回一个可变的 ref 对象，其 .current 属性被初始化为传入的参数。返回的 ref 对象在组件的整个生命周期内保持不变。</h3><pre><code>const refContainer = useRef(null);</code></pre>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><pre><code>function TextInputWithFocusButton() &#123;
  const inputEl = useRef(null);
  const onButtonClick = () =&gt; &#123;
    // `current` 指向已挂载到 DOM 上的文本输入元素
    inputEl.current.focus();
  &#125;;
  return (
    &lt;div&gt;
      &lt;input ref=&#123;inputEl&#125; type=&quot;text&quot;/&gt;
      &lt;button onClick=&#123;onButtonClick&#125;&gt;Focus the input&lt;/button&gt;
    &lt;/div&gt;
  );
&#125;</code></pre>
<h3 id="还有很多hook方法-例如"><a href="#还有很多hook方法-例如" class="headerlink" title="还有很多hook方法 例如"></a>还有很多hook方法 例如</h3><ol>
<li>useImperativeHandle</li>
<li>useLayoutEffect</li>
<li>useDebugValue</li>
</ol>
<p>下次再见</p>

      
       <hr><span style="font-style: italic;color: gray;"> 转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。可以在下面评论区评论，也可以邮件至 jaytp@qq.com </span>
    </div>
</article>





    <div id="comments"></div>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">

<script type="text/javascript">
    $.getScript('/js/gitalk.js', function () {
        var gitalk = new Gitalk({
            clientID: '',
            clientSecret: '',
            repo: 'yelog.github.io',
            owner: 'yelog',
            admin: ['yelog'],
            id: decodeURI(location.pathname),
            distractionFreeMode: 'true',
            language: 'zh-CN',
            perPage: parseInt('10',10)
        })
        gitalk.render('comments')
    })
</script>




    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2016-2020 Yelog
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        

        /*高亮代码块行号*/
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    

</script>

<!--加入行号的高亮代码块样式-->

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>






<div class="mobile-menus-out" >

</div>
<div class="mobile-menus">
    
    
    <a class="dynamic-menu site_url"   href="/photo">相册</a>
    
    
    
</div>


</html>

<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>egg和koa面试题总结 | Hexo</title>
  <meta name="keywords" content="">
  <meta name="description" content="egg和koa面试题总结 | Hexo">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="(1).  Node模块机制1.Node中，每个文件模块都是一个对象，它的定义如下function Module(id, parent) &amp;#123;  this.id &#x3D; id;  this.exports &#x3D; &amp;#123;&amp;#125;;  this.parent &#x3D; parent;  this.filename &#x3D; null;  this.loaded &#x3D; false;  this.child">
<meta property="og:type" content="article">
<meta property="og:title" content="egg和koa面试题总结">
<meta property="og:url" content="http://example.com/2021/02/22/vue%E5%92%8Creact%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="(1).  Node模块机制1.Node中，每个文件模块都是一个对象，它的定义如下function Module(id, parent) &amp;#123;  this.id &#x3D; id;  this.exports &#x3D; &amp;#123;&amp;#125;;  this.parent &#x3D; parent;  this.filename &#x3D; null;  this.loaded &#x3D; false;  this.child">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://img.jbzj.com/file_images/article/201910/2019100915292845.png">
<meta property="article:published_time" content="2021-02-22T08:08:41.000Z">
<meta property="article:modified_time" content="2021-02-22T12:33:08.109Z">
<meta property="article:author" content="前端菜鸟">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img.jbzj.com/file_images/article/201910/2019100915292845.png">


<link rel="icon" href="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=3014093926,41837070&fm=26&gp=0.jpg">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/atom-light.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 5.3.0"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/" class="avatar_target">
    <img class="avatar" src="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=3014093926,41837070&amp;fm=26&amp;gp=0.jpg" />
</a>
<div class="author">
    <span>前端菜鸟</span>
</div>

<div class="icon">
    
        
        <a title="rss" href="/atom.xml" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-rss"></use>
                </svg>
            
        </a>
        
    
        
        <a title="github" href="https://github.com/18801214376lk" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-github"></use>
                </svg>
            
        </a>
        
    
        
    
        
    
        
        <a title="weibo" href="https://weibo.com/u/7384469670/home?wvr=5" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-weibo"></use>
                </svg>
            
        </a>
        
    
        
    
        
    
        
    
        
        <a title="juejin" href="https://juejin.cn/user/4344919342731837" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-juejin"></use>
                </svg>
            
        </a>
        
    
        
        <a title="email" href="mailto:18801214376@qq.com" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-email"></use>
                </svg>
            
        </a>
        
    
        
        <a title="qq" href="http://wpa.qq.com/msgrd?v=3&uin=2655883468&site=qq&menu=yes" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-qq"></use>
                </svg>
            
        </a>
        
    
        
        <a title="kugou" href="https://www.kugou.com/" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-kugou"></use>
                </svg>
            
        </a>
        
    
</div>



<a class="more-menus">更多菜单</a>


<ul>
    <li><div class="all active" data-rel="All">All<small>(11)</small></div></li>
    
</ul>
<div class="left-bottom">
    <div class="menus">
    
    
    <a class="dynamic-menu site_url"   href="/photo">相册</a>
    
    
    
    </div>
    <div><a class="about  hasFriend  site_url"  href="/about">五福临门</a><a style="width: 50%"  class="friends">小白</a></div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="11">

<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        Links
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">All</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" />
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>js</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>proxy代理</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>前端</a>
            </li>
        
    </div>

</div>

    
    <nav id="title-list-nav">
        
        <a  class="All "
           href="/2021/02/22/vue%E5%92%8Creact%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="egg和koa面试题总结">egg和koa面试题总结</span>
            <span class="post-date" title="2021-02-22 16:08:41">2021/02/22</span>
        </a>
        
        <a  class="All "
           href="/2021/01/28/vue%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="vue面试题整理">vue面试题整理</span>
            <span class="post-date" title="2021-01-28 21:01:50">2021/01/28</span>
        </a>
        
        <a  class="All "
           href="/2021/01/25/proxy/"
           data-tag="proxy代理"
           data-author="" >
            <span class="post-title" title="proxy">proxy</span>
            <span class="post-date" title="2021-01-25 21:07:06">2021/01/25</span>
        </a>
        
        <a  class="All "
           href="/2021/01/12/%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/"
           data-tag="前端"
           data-author="" >
            <span class="post-title" title="防抖与节流">防抖与节流</span>
            <span class="post-date" title="2021-01-12 08:38:47">2021/01/12</span>
        </a>
        
        <a  class="All "
           href="/2021/01/11/%E5%90%8C%E6%BA%90%E5%8F%8A%E8%B7%A8%E5%9F%9F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="同源及跨域">同源及跨域</span>
            <span class="post-date" title="2021-01-11 15:23:43">2021/01/11</span>
        </a>
        
        <a  class="All "
           href="/2021/01/04/Object/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="TypeScript">TypeScript</span>
            <span class="post-date" title="2021-01-04 08:30:13">2021/01/04</span>
        </a>
        
        <a  class="All "
           href="/2020/12/30/TypeScript/"
           data-tag="js"
           data-author="" >
            <span class="post-title" title="TypeScript">TypeScript</span>
            <span class="post-date" title="2020-12-30 08:30:13">2020/12/30</span>
        </a>
        
        <a  class="All "
           href="/2020/12/30/%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="JavaScript的严格模式">JavaScript的严格模式</span>
            <span class="post-date" title="2020-12-30 08:30:13">2020/12/30</span>
        </a>
        
        <a  class="All "
           href="/2020/12/28/class/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="class的总结">class的总结</span>
            <span class="post-date" title="2020-12-28 20:39:20">2020/12/28</span>
        </a>
        
        <a  class="All "
           href="/2020/12/27/hook/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="hook的整理使用">hook的整理使用</span>
            <span class="post-date" title="2020-12-27 19:40:43">2020/12/27</span>
        </a>
        
        <a  class="All "
           href="/2020/12/25/hello-world/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Hello World">Hello World</span>
            <span class="post-date" title="2020-12-25 14:31:04">2020/12/25</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>
    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-vue和react面试题总结" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">egg和koa面试题总结</h1>
    
    <div class="article-meta">
        
        
        
        
    </div>
    <div class="article-meta">
        
            Created At : <time class="date" title='Updated At: 2021-02-22 20:33:08'>2021-02-22 16:08</time>
        
    </div>
    <div class="article-meta">
        
        
        <span id="busuanzi_container_page_pv">
            Views 👀 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
        <span class="top-comment" title="跳转至评论区">
            <a href="#comments">
                Comment:<span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </a>
        </span>
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Node%E6%A8%A1%E5%9D%97%E6%9C%BA%E5%88%B6"><span class="toc-text">(1).  Node模块机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Node%E4%B8%AD%EF%BC%8C%E6%AF%8F%E4%B8%AA%E6%96%87%E4%BB%B6%E6%A8%A1%E5%9D%97%E9%83%BD%E6%98%AF%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%EF%BC%8C%E5%AE%83%E7%9A%84%E5%AE%9A%E4%B9%89%E5%A6%82%E4%B8%8B"><span class="toc-text">1.Node中，每个文件模块都是一个对象，它的定义如下</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%AF%B7%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8Brequire%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="toc-text">2.请介绍一下require的模块加载机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9D%97%E6%97%B6%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E6%AF%8F%E4%B8%AA%E6%A8%A1%E5%9D%97%E9%83%BD%E6%9C%89-dirname-filename%E5%B1%9E%E6%80%A7%E5%91%A2%EF%BC%8Cnew-Module%E7%9A%84%E6%97%B6%E5%80%99%E6%88%91%E4%BB%AC%E7%9C%8B%E5%88%B0%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%E6%B2%A1%E6%9C%89%E8%BF%99%E4%B8%A4%E4%B8%AA%E5%B1%9E%E6%80%A7%E7%9A%84%EF%BC%8C%E9%82%A3%E4%B9%88%E8%BF%99%E4%B8%A4%E4%B8%AA%E5%B1%9E%E6%80%A7%E6%98%AF%E4%BB%8E%E5%93%AA%E9%87%8C%E6%9D%A5%E7%9A%84"><span class="toc-text">3. 加载模块时，为什么每个模块都有__dirname,__filename属性呢，new Module的时候我们看到第一部分没有这两个属性的，那么这两个属性是从哪里来的?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%88%91%E4%BB%AC%E7%9F%A5%E9%81%93node%E5%AF%BC%E5%87%BA%E6%A8%A1%E5%9D%97%E6%9C%89%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%8C%E4%B8%80%E7%A7%8D%E6%98%AFexports-xxx-xxx%E5%92%8CModule-exports-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E5%90%97"><span class="toc-text">4.我们知道node导出模块有两种方式，一种是exports.xxx&#x3D;xxx和Module.exports&#x3D;{}有什么区别吗</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-node%E5%BC%82%E6%AD%A5"><span class="toc-text">(2). node异步</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%AF%B7%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8BNode%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-text">1 请介绍一下Node事件循环的流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%9C%A8%E6%AF%8F%E4%B8%AAtick%E7%9A%84%E8%BF%87%E7%A8%8B%E4%B8%AD%EF%BC%8C%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%9C%89%E4%BA%8B%E4%BB%B6%E9%9C%80%E8%A6%81%E5%A4%84%E7%90%86%E5%91%A2%EF%BC%9F"><span class="toc-text">2.在每个tick的过程中，如何判断是否有事件需要处理呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%AF%B7%E8%B0%88%E4%B8%80%E4%B8%8B%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%B8%B8%E8%A7%81%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E5%8E%9F%E5%9B%A0%EF%BC%8C%E5%92%8C%E6%8E%92%E6%9F%A5%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-text">3.请谈一下内存泄漏是什么，以及常见内存泄漏的原因，和排查的方法？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-text">什么是内存泄漏</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Buffer%E6%A8%A1%E5%9D%97"><span class="toc-text">3.Buffer模块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%96%B0%E5%BB%BABuffer%E4%BC%9A%E5%8D%A0%E7%94%A8V8%E5%88%86%E9%85%8D%E7%9A%84%E5%86%85%E5%AD%98%E5%90%97"><span class="toc-text">1 新建Buffer会占用V8分配的内存吗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Buffer-alloc%E5%92%8CBuffer-allocUnsafe%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">2.Buffer.alloc和Buffer.allocUnsafe的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Buffer%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%9C%BA%E5%88%B6"><span class="toc-text">3. Buffer的内存分配机制**</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Buffer%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98"><span class="toc-text">4.Buffer乱码问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E8%AF%B7%E9%97%AE%E5%88%9B%E5%BB%BA%E5%AD%90%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%8C%E7%AE%80%E5%8D%95%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%AE%83%E4%BB%AC%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">5 请问创建子进程的方法有哪些，简单说一下它们的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E8%AF%B7%E9%97%AE%E4%BD%A0%E7%9F%A5%E9%81%93spawn%E5%9C%A8%E5%88%9B%E5%BB%BA%E5%AD%90%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E7%AC%AC%E4%B8%89%E4%B8%AA%E5%8F%82%E6%95%B0%E6%9C%89%E4%B8%80%E4%B8%AAstdio%E9%80%89%E9%A1%B9%E5%90%97%EF%BC%8C%E8%BF%99%E4%B8%AA%E9%80%89%E9%A1%B9%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E9%BB%98%E8%AE%A4%E7%9A%84%E5%80%BC%E6%98%AF%E4%BB%80%E4%B9%88%E3%80%82"><span class="toc-text">6. 请问你知道spawn在创建子进程的时候，第三个参数有一个stdio选项吗，这个选项的作用是什么，默认的值是什么。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E8%AF%B7%E9%97%AE%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAnode%E5%AD%90%E8%BF%9B%E7%A8%8B%E8%A2%AB%E6%9D%80%E6%AD%BB%EF%BC%8C%E7%84%B6%E5%90%8E%E8%87%AA%E5%8A%A8%E9%87%8D%E5%90%AF%E4%BB%A3%E7%A0%81%E7%9A%84%E6%80%9D%E8%B7%AF"><span class="toc-text">7.请问实现一个node子进程被杀死，然后自动重启代码的思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%AE%9E%E7%8E%B0%E9%99%90%E9%87%8F%E9%87%8D%E5%90%AF%EF%BC%8C%E6%AF%94%E5%A6%82%E6%88%91%E6%9C%80%E5%A4%9A%E8%AE%A9%E5%85%B6%E5%9C%A81%E5%88%86%E9%92%9F%E5%86%85%E9%87%8D%E5%90%AF5%E6%AC%A1%EF%BC%8C%E8%B6%85%E8%BF%87%E4%BA%86%E5%B0%B1%E6%8A%A5%E8%AD%A6%E7%BB%99%E8%BF%90%E7%BB%B4"><span class="toc-text">8.实现限量重启，比如我最多让其在1分钟内重启5次，超过了就报警给运维</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="toc-text">4.中间件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%A6%82%E6%9E%9C%E4%BD%BF%E7%94%A8%E8%BF%87koa%E3%80%81egg%E8%BF%99%E4%B8%A4%E4%B8%AANode%E6%A1%86%E6%9E%B6%EF%BC%8C%E8%AF%B7%E7%AE%80%E8%BF%B0%E5%85%B6%E4%B8%AD%E7%9A%84%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%8E%9F%E7%90%86%EF%BC%8C%E6%9C%80%E5%A5%BD%E7%94%A8%E4%BB%A3%E7%A0%81%E8%A1%A8%E7%A4%BA%E4%B8%80%E4%B8%8B"><span class="toc-text">1.如果使用过koa、egg这两个Node框架，请简述其中的中间件原理，最好用代码表示一下</span></a></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-Node模块机制"><a href="#1-Node模块机制" class="headerlink" title="(1).  Node模块机制"></a>(1).  Node模块机制</h2><h3 id="1-Node中，每个文件模块都是一个对象，它的定义如下"><a href="#1-Node中，每个文件模块都是一个对象，它的定义如下" class="headerlink" title="1.Node中，每个文件模块都是一个对象，它的定义如下"></a>1.Node中，每个文件模块都是一个对象，它的定义如下</h3><pre><code class="js">function Module(id, parent) &#123;
 this.id = id;
 this.exports = &#123;&#125;;
 this.parent = parent;
 this.filename = null;
 this.loaded = false;
 this.children = [];
&#125;
 
module.exports = Module;
 
var module = new Module(filename, parent);</code></pre>
<p>所有的模块都是 Module 的实例。可以看到，当前模块（module.js）也是 Module 的一个实例。</p>
<h3 id="2-请介绍一下require的模块加载机制"><a href="#2-请介绍一下require的模块加载机制" class="headerlink" title="2.请介绍一下require的模块加载机制"></a>2.请介绍一下require的模块加载机制</h3><ul>
<li>1、先计算模块路径</li>
<li>2、如果模块在缓存里面，取出缓存</li>
<li>3、加载模块</li>
<li>4、的输出模块的exports属性即可</li>
</ul>
<pre><code class="js">// require 其实内部调用 Module._load 方法
Module._load = function(request, parent, isMain) &#123;
 // 计算绝对路径
 var filename = Module._resolveFilename(request, parent);

 // 第一步：如果有缓存，取出缓存
 var cachedModule = Module._cache[filename];
 if (cachedModule) &#123;
 return cachedModule.exports;

 // 第二步：是否为内置模块
 if (NativeModule.exists(filename)) &#123;
 return NativeModule.require(filename);
 &#125;

 /********************************这里注意了**************************/
 // 第三步：生成模块实例，存入缓存
 // 这里的Module就是我们上面的1.1定义的Module
 var module = new Module(filename, parent);
 Module._cache[filename] = module;

 /********************************这里注意了**************************/
 // 第四步：加载模块
 // 下面的module.load实际上是Module原型上有一个方法叫Module.prototype.load
 try &#123;
 module.load(filename);
 hadException = false;
 &#125; finally &#123;
 if (hadException) &#123;
  delete Module._cache[filename];
 &#125;
 &#125;

 // 第五步：输出模块的exports属性
 return module.exports;
&#125;;</code></pre>
<h3 id="3-加载模块时，为什么每个模块都有-dirname-filename属性呢，new-Module的时候我们看到第一部分没有这两个属性的，那么这两个属性是从哪里来的"><a href="#3-加载模块时，为什么每个模块都有-dirname-filename属性呢，new-Module的时候我们看到第一部分没有这两个属性的，那么这两个属性是从哪里来的" class="headerlink" title="3. 加载模块时，为什么每个模块都有__dirname,__filename属性呢，new Module的时候我们看到第一部分没有这两个属性的，那么这两个属性是从哪里来的?"></a>3. 加载模块时，为什么每个模块都有__dirname,__filename属性呢，new Module的时候我们看到第一部分没有这两个属性的，那么这两个属性是从哪里来的?</h3><pre><code class="js">// 上面(1.2部分)的第四步module.load(filename)
// 这一步，module模块相当于被包装了，包装形式如下
// 加载js模块，相当于下面的代码（加载node模块和json模块逻辑不一样）
(function (exports, require, module, __filename, __dirname) &#123;
 // 模块源码
 // 假如模块代码如下
 var math = require(&#39;math&#39;);
 exports.area = function(radius)&#123;
  return Math.PI * radius * radius
 &#125;
&#125;);</code></pre>
<p><strong>每个module里面都会传入__filename, __dirname参数，这两个参数并不是module本身就有的，是外界传入的</strong></p>
<h3 id="4-我们知道node导出模块有两种方式，一种是exports-xxx-xxx和Module-exports-有什么区别吗"><a href="#4-我们知道node导出模块有两种方式，一种是exports-xxx-xxx和Module-exports-有什么区别吗" class="headerlink" title="4.我们知道node导出模块有两种方式，一种是exports.xxx=xxx和Module.exports={}有什么区别吗"></a>4.我们知道node导出模块有两种方式，一种是exports.xxx=xxx和Module.exports={}有什么区别吗</h3><ul>
<li>exports其实就是module.exports</li>
<li>其实3问题的代码已经说明问题了，接着我引用廖雪峰大神的讲解，希望能讲的更清楚</li>
</ul>
<pre><code class="js">module.exports vs exports
很多时候，你会看到，在Node环境中，有两种方法可以在一个模块中输出变量：

方法一：对module.exports赋值：

// hello.js

function hello() &#123;
 console.log(&#39;Hello, world!&#39;);
&#125;

function greet(name) &#123;
 console.log(&#39;Hello, &#39; + name + &#39;!&#39;);
&#125;

module.exports = &#123;
 hello: hello,
 greet: greet
&#125;;
方法二：直接使用exports：

// hello.js

function hello() &#123;
 console.log(&#39;Hello, world!&#39;);
&#125;

function greet(name) &#123;
 console.log(&#39;Hello, &#39; + name + &#39;!&#39;);
&#125;

function hello() &#123;
 console.log(&#39;Hello, world!&#39;);
&#125;

exports.hello = hello;
exports.greet = greet;
但是你不可以直接对exports赋值：

// 代码可以执行，但是模块并没有输出任何变量:
exports = &#123;
 hello: hello,
 greet: greet
&#125;;
如果你对上面的写法感到十分困惑，不要着急，我们来分析Node的加载机制：

首先，Node会把整个待加载的hello.js文件放入一个包装函数load中执行。在执行这个load()函数前，Node准备好了module变量：

var module = &#123;
 id: &#39;hello&#39;,
 exports: &#123;&#125;
&#125;;
load()函数最终返回module.exports：

var load = function (exports, module) &#123;
 // hello.js的文件内容
 ...
 // load函数返回:
 return module.exports;
&#125;;

var exported = load(module.exports, module);
也就是说，默认情况下，Node准备的exports变量和module.exports变量实际上是同一个变量，并且初始化为空对象&#123;&#125;，于是，我们可以写：

exports.foo = function () &#123; return &#39;foo&#39;; &#125;;
exports.bar = function () &#123; return &#39;bar&#39;; &#125;;
也可以写：

module.exports.foo = function () &#123; return &#39;foo&#39;; &#125;;
module.exports.bar = function () &#123; return &#39;bar&#39;; &#125;;
换句话说，Node默认给你准备了一个空对象&#123;&#125;，这样你可以直接往里面加东西。

但是，如果我们要输出的是一个函数或数组，那么，只能给module.exports赋值：

module.exports = function () &#123; return &#39;foo&#39;; &#125;;
给exports赋值是无效的，因为赋值后，module.exports仍然是空对象&#123;&#125;。

结论
如果要输出一个键值对象&#123;&#125;，可以利用exports这个已存在的空对象&#123;&#125;，并继续在上面添加新的键值；

如果要输出一个函数或数组，必须直接对module.exports对象赋值。

所以我们可以得出结论：直接对module.exports赋值，可以应对任何情况：

module.exports = &#123;
 foo: function () &#123; return &#39;foo&#39;; &#125;
&#125;;
或者：

module.exports = function () &#123; return &#39;foo&#39;; &#125;;
最终，我们强烈建议使用module.exports = xxx的方式来输出模块变量，这样，你只需要记忆一种方法。</code></pre>
<h2 id="2-node异步"><a href="#2-node异步" class="headerlink" title="(2). node异步"></a>(2). node异步</h2><h3 id="1-请介绍一下Node事件循环的流程"><a href="#1-请介绍一下Node事件循环的流程" class="headerlink" title="1 请介绍一下Node事件循环的流程"></a>1 请介绍一下Node事件循环的流程</h3><ul>
<li>在进程启动时，Node便会创建一个类似于while(true)的循环，每执行一次循环体的过程我们成为Tick。</li>
<li>每个Tick的过程就是查看是否有事件待处理。如果有就取出事件及其相关的回调函数。然后进入下一个循环，如果不再有事件处理，就退出进程。</li>
</ul>
<h3 id="2-在每个tick的过程中，如何判断是否有事件需要处理呢？"><a href="#2-在每个tick的过程中，如何判断是否有事件需要处理呢？" class="headerlink" title="2.在每个tick的过程中，如何判断是否有事件需要处理呢？"></a>2.在每个tick的过程中，如何判断是否有事件需要处理呢？</h3><ol>
<li>每个事件循环中有一个或者多个观察者，而判断是否有事件需要处理的过程就是向这些观察者询问是否有要处理的事件。</li>
<li>在Node中，事件主要来源于网络请求、文件的I/O等，这些事件对应的观察者有文件I/O观察者，网络I/O的观察者。</li>
<li>事件循环是一个典型的生产者/消费者模型。异步I/O，网络请求等则是事件的生产者，源源不断为Node提供不同类型的事件，这些事件被传递到对应的观察者那里，事件循环则从观察者那里取出事件并处理。</li>
<li>在windows下，这个循环基于IOCP创建，在*nix下则基于多线程创建</li>
</ol>
<h3 id="3-请谈一下内存泄漏是什么，以及常见内存泄漏的原因，和排查的方法？"><a href="#3-请谈一下内存泄漏是什么，以及常见内存泄漏的原因，和排查的方法？" class="headerlink" title="3.请谈一下内存泄漏是什么，以及常见内存泄漏的原因，和排查的方法？"></a>3.请谈一下内存泄漏是什么，以及常见内存泄漏的原因，和排查的方法？</h3><h4 id="什么是内存泄漏"><a href="#什么是内存泄漏" class="headerlink" title="什么是内存泄漏"></a>什么是内存泄漏</h4><ul>
<li>内存泄漏(Memory Leak)指由于疏忽或错误造成程序未能释放已经不再使用的内存的情况。</li>
<li>如果内存泄漏的位置比较关键，那么随着处理的进行可能持有越来越多的无用内存，这些无用的内存变多会引起服务器响应速度变慢。</li>
<li>严重的情况下导致内存达到某个极限(可能是进程的上限，如 v8 的上限;也可能是系统可提供的内存上限)会使得应用程序崩溃。</li>
</ul>
<p>常见内存泄漏</p>
<p>一、全局变量</p>
<pre><code class="js">a = 10; //未声明对象。 
global.b = 11; //全局变量引用 这种比较简单的原因，全局变量直接挂在 root 对象上，不会被清除掉。</code></pre>
<p>二、闭包</p>
<pre><code class="js">function out() &#123;
    const bigData = new Buffer(100);  
    inner = function () &#123;

    &#125; 
&#125;</code></pre>
<p>闭包会引用到父级函数中的变量，如果闭包未释放，就会导致内存泄漏。上面例子是 inner 直接挂在了 root 上，那么每次执行 out 函数所产生的 bigData 都不会释放，从而导致内存泄漏。</p>
<p>需要注意的是，这里举得例子只是简单的将引用挂在全局对象上，实际的业务情况可能是挂在某个可以从 root 追溯到的对象上导致的。</p>
<p>三、Node.js 的事件监听也可能出现的内存泄漏。例如对同一个事件重复监听，忘记移除(removeListener)，将造成内存泄漏。这种情况很容易在复用对象上添加事件时出现，所以事件重复监听可能收到如下警告：</p>
<pre><code>emitter.setMaxListeners() to increase limit</code></pre>
<p>例如，Node.js 中 Agent 的 keepAlive 为 true 时，可能造成的内存泄漏。当 Agent keepAlive 为 true 的时候，将会复用之前使用过的 socket，如果在 socket 上添加事件监听，忘记清除的话，因为 socket 的复用，将导致事件重复监听从而产生内存泄漏。</p>
<p>原理上与前一个添加事件监听的时候忘了清除是一样的。在使用 Node.js 的 http 模块时，不通过 keepAlive 复用是没有问题的，复用了以后就会可能产生内存泄漏。所以，你需要了解添加事件监听的对象的生命周期，并注意自行移除。</p>
<p><strong>排查方法</strong></p>
<ul>
<li>想要定位内存泄漏，通常会有两种情况：</li>
<li>对于只要正常使用就可以重现的内存泄漏，这是很简单的情况只要在测试环境模拟就可以排查了。</li>
<li>对于偶然的内存泄漏，一般会与特殊的输入有关系。想稳定重现这种输入是很耗时的过程。如果不能通过代码的日志定位到这个特殊的输入，那么推荐去生产环境打印内存快照了。</li>
<li>需要注意的是，打印内存快照是很耗 CPU 的操作，可能会对线上业务造成影响。快照工具推荐使用 heapdump 用来保存内存快照，使用 devtool 来查看内存快照。</li>
<li>使用 heapdump 保存内存快照时，只会有 Node.js 环境中的对象，不会受到干扰(如果使用 node-inspector 的话，快照中会有前端的变量干扰)。</li>
<li>PS：安装 heapdump 在某些 Node.js 版本上可能出错，建议使用 npm install heapdump -target=Node.js 版本来安装。</li>
</ul>
<h2 id="3-Buffer模块"><a href="#3-Buffer模块" class="headerlink" title="3.Buffer模块"></a>3.Buffer模块</h2><h3 id="1-新建Buffer会占用V8分配的内存吗"><a href="#1-新建Buffer会占用V8分配的内存吗" class="headerlink" title="1 新建Buffer会占用V8分配的内存吗"></a>1 新建Buffer会占用V8分配的内存吗</h3><p>  不会，Buffer属于堆外内存，不是V8分配的。</p>
<h3 id="2-Buffer-alloc和Buffer-allocUnsafe的区别"><a href="#2-Buffer-alloc和Buffer-allocUnsafe的区别" class="headerlink" title="2.Buffer.alloc和Buffer.allocUnsafe的区别"></a>2.<strong>Buffer.alloc和Buffer.allocUnsafe的区别</strong></h3><p>Buffer.allocUnsafe创建的 Buffer 实例的底层内存是未初始化的。 新创建的 Buffer 的内容是未知的，可能包含敏感数据。 使用 Buffer.alloc() 可以创建以零初始化的 Buffer 实例。</p>
<h3 id="3-Buffer的内存分配机制"><a href="#3-Buffer的内存分配机制" class="headerlink" title="3. Buffer的内存分配机制**"></a>3. Buffer的内存分配机制**</h3><p>为了高效的使用申请来的内存，Node采用了slab分配机制。slab是一种动态的内存管理机制。Node以8kb为界限来来区分Buffer为大对象还是小对象，如果是小于8kb就是小Buffer，大于8kb就是大Buffer。</p>
<p>例如第一次分配一个1024字节的Buffer，Buffer.alloc(1024),那么这次分配就会用到一个slab，接着如果继续Buffer.alloc(1024),那么上一次用的slab的空间还没有用完，因为总共是8kb，1024+1024 = 2048个字节，没有8kb，所以就继续用这个slab给Buffer分配空间</p>
<h3 id="4-Buffer乱码问题"><a href="#4-Buffer乱码问题" class="headerlink" title="4.Buffer乱码问题"></a>4.Buffer乱码问题</h3><p>设置rs.setEncoding(‘utf8’)可以解决乱码问题</p>
<h3 id="5-请问创建子进程的方法有哪些，简单说一下它们的区别"><a href="#5-请问创建子进程的方法有哪些，简单说一下它们的区别" class="headerlink" title="5 请问创建子进程的方法有哪些，简单说一下它们的区别"></a>5 请问创建子进程的方法有哪些，简单说一下它们的区别</h3><p>创建子进程的方法大致有：</p>
<ul>
<li>spawn()： 启动一个子进程来执行命令</li>
<li>exec(): 启动一个子进程来执行命令，与spawn()不同的是其接口不同，它有一个回调函数获知子进程的状况</li>
<li>execFlie(): 启动一个子进程来执行可执行文件</li>
<li>fork(): 与spawn()类似，不同电在于它创建Node子进程需要执行js文件</li>
<li>spawn()与exec()、execFile()不同的是，后两者创建时可以指定timeout属性设置超时时间，一旦创建的进程超过设定的时间就会被杀死</li>
<li>exec()与execFile()不同的是，exec()适合执行已有命令，execFile()适合执行文件</li>
</ul>
<h3 id="6-请问你知道spawn在创建子进程的时候，第三个参数有一个stdio选项吗，这个选项的作用是什么，默认的值是什么。"><a href="#6-请问你知道spawn在创建子进程的时候，第三个参数有一个stdio选项吗，这个选项的作用是什么，默认的值是什么。" class="headerlink" title="6. 请问你知道spawn在创建子进程的时候，第三个参数有一个stdio选项吗，这个选项的作用是什么，默认的值是什么。"></a>6. <strong>请问你知道spawn在创建子进程的时候，第三个参数有一个stdio选项吗，这个选项的作用是什么，默认的值是什么。</strong></h3><ul>
<li>选项用于配置在父进程和子进程之间建立的管道。</li>
<li>默认情况下，子进程的 stdin、 stdout 和 stderr 会被重定向到 ChildProcess 对象上相应的 subprocess.stdin、subprocess.stdout 和 subprocess.stderr 流。</li>
<li>这相当于将 options.stdio 设置为 [‘pipe’, ‘pipe’, ‘pipe’]。</li>
</ul>
<h3 id="7-请问实现一个node子进程被杀死，然后自动重启代码的思路"><a href="#7-请问实现一个node子进程被杀死，然后自动重启代码的思路" class="headerlink" title="7.请问实现一个node子进程被杀死，然后自动重启代码的思路"></a>7.<strong>请问实现一个node子进程被杀死，然后自动重启代码的思路</strong></h3><p>在创建子进程的时候就让子进程监听exit事件，如果被杀死就重新fork一下</p>
<pre><code class="js">var createWorker = function()&#123;
 var worker = fork(__dirname + &#39;worker.js&#39;)
 worker.on(&#39;exit&#39;, function()&#123;
  console.log(&#39;Worker&#39; + worker.pid + &#39;exited&#39;);
  // 如果退出就创建新的worker
  createWorker()
 &#125;)
&#125;</code></pre>
<h3 id="8-实现限量重启，比如我最多让其在1分钟内重启5次，超过了就报警给运维"><a href="#8-实现限量重启，比如我最多让其在1分钟内重启5次，超过了就报警给运维" class="headerlink" title="8.实现限量重启，比如我最多让其在1分钟内重启5次，超过了就报警给运维"></a>8.<strong>实现限量重启，比如我最多让其在1分钟内重启5次，超过了就报警给运维</strong></h3><ul>
<li>思路大概是在创建worker的时候，就判断创建的这个worker是否在1分钟内重启次数超过5次</li>
<li>所以每一次创建worker的时候都要记录这个worker 创建时间，放入一个数组队列里面，每次创建worker都去取队列里前5条记录</li>
<li>如果这5条记录的时间间隔小于1分钟，就说明到了报警的时候了</li>
</ul>
<h2 id="4-中间件"><a href="#4-中间件" class="headerlink" title="4.中间件"></a>4.中间件</h2><h3 id="1-如果使用过koa、egg这两个Node框架，请简述其中的中间件原理，最好用代码表示一下"><a href="#1-如果使用过koa、egg这两个Node框架，请简述其中的中间件原理，最好用代码表示一下" class="headerlink" title="1.如果使用过koa、egg这两个Node框架，请简述其中的中间件原理，最好用代码表示一下"></a>1.如果使用过koa、egg这两个Node框架，请简述其中的中间件原理，最好用代码表示一下</h3><p><img src="https://img.jbzj.com/file_images/article/201910/2019100915292845.png" alt="img"></p>
<p>中间件执行就像洋葱一样，最早use的中间件，就放在最外层。处理顺序从左到右，左边接收一个request，右边输出返回response</p>
<p>一般的中间件都会执行两次，调用next之前为第一次，调用next时把控制传递给下游的下一个中间件。当下游不再有中间件或者没有执行next函数时，就将依次恢复上游中间件的行为，让上游中间件执行next之后的代码</p>
<p>例如</p>
<pre><code class="js">const Koa = require(&#39;koa&#39;)
const app = new Koa()
app.use((ctx, next) =&gt; &#123;
 console.log(1)
 next()
 console.log(3)
&#125;)
app.use((ctx) =&gt; &#123;
 console.log(2)
&#125;)
app.listen(3001)
执行结果是1=&gt;2=&gt;3</code></pre>
<p>koa中间件实现源码大致思路如下：</p>
<pre><code class="js">// 注意其中的compose函数，这个函数是实现中间件洋葱模型的关键
// 场景模拟
// 异步 promise 模拟
const delay = async () =&gt; &#123;
 return new Promise((resolve, reject) =&gt; &#123;
 setTimeout(() =&gt; &#123;
  resolve();
 &#125;, 2000);
 &#125;);
&#125;
// 中间间模拟
const fn1 = async (ctx, next) =&gt; &#123;
 console.log(1);
 await next();
 console.log(2);
&#125;
const fn2 = async (ctx, next) =&gt; &#123;
 console.log(3);
 await delay();
 await next();
 console.log(4);
&#125;
const fn3 = async (ctx, next) =&gt; &#123;
 console.log(5);
&#125;

const middlewares = [fn1, fn2, fn3];

// compose 实现洋葱模型
const compose = (middlewares, ctx) =&gt; &#123;
 const dispatch = (i) =&gt; &#123;
 let fn = middlewares[i];
 if(!fn)&#123; return Promise.resolve() &#125;
 return Promise.resolve(fn(ctx, () =&gt; &#123;
  return dispatch(i+1);
 &#125;));
 &#125;
 return dispatch(0);
&#125;

compose(middlewares, 1);</code></pre>

      
       <hr><span style="font-style: italic;color: gray;"> 转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。可以在下面评论区评论，也可以邮件至 jaytp@qq.com </span>
    </div>
</article>





    <div id="comments"></div>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">

<script type="text/javascript">
    $.getScript('/js/gitalk.js', function () {
        var gitalk = new Gitalk({
            clientID: '',
            clientSecret: '',
            repo: 'yelog.github.io',
            owner: 'yelog',
            admin: ['yelog'],
            id: decodeURI(location.pathname),
            distractionFreeMode: 'true',
            language: 'zh-CN',
            perPage: parseInt('10',10)
        })
        gitalk.render('comments')
    })
</script>




    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2016-2020 Yelog
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        

        /*高亮代码块行号*/
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    

</script>

<!--加入行号的高亮代码块样式-->

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>






<div class="mobile-menus-out" >

</div>
<div class="mobile-menus">
    
    
    <a class="dynamic-menu site_url"   href="/photo">相册</a>
    
    
    
</div>


</html>
